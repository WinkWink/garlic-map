{"ast":null,"code":"'use strict';\n\nvar merge = require('./functions/merge');\nfunction sortObject(obj) {\n  return Object.keys(obj).sort(function (a, b) {\n    return a.localeCompare(b);\n  }).reduce(function (acc, curr) {\n    acc[curr] = obj[curr];\n    return acc;\n  }, {});\n}\nvar requestBuilder = {\n  /**\n   * Get all the queries to send to the client, those queries can used directly\n   * with the Algolia client.\n   * @private\n   * @return {object[]} The queries\n   */\n  _getQueries: function getQueries(index, state) {\n    var queries = [];\n\n    // One query for the hits\n    queries.push({\n      indexName: index,\n      params: requestBuilder._getHitsSearchParams(state)\n    });\n\n    // One for each disjunctive facets\n    state.getRefinedDisjunctiveFacets().forEach(function (refinedFacet) {\n      queries.push({\n        indexName: index,\n        params: requestBuilder._getDisjunctiveFacetSearchParams(state, refinedFacet)\n      });\n    });\n\n    // More to get the parent levels of the hierarchical facets when refined\n    state.getRefinedHierarchicalFacets().forEach(function (refinedFacet) {\n      var hierarchicalFacet = state.getHierarchicalFacetByName(refinedFacet);\n      var currentRefinement = state.getHierarchicalRefinement(refinedFacet);\n      var separator = state._getHierarchicalFacetSeparator(hierarchicalFacet);\n\n      // If we are deeper than level 0 (starting from `beer > IPA`)\n      // we want to get all parent values\n      if (currentRefinement.length > 0 && currentRefinement[0].split(separator).length > 1) {\n        // We generate a map of the filters we will use for our facet values queries\n        var filtersMap = currentRefinement[0].split(separator).slice(0, -1).reduce(function createFiltersMap(map, segment, level) {\n          return map.concat({\n            attribute: hierarchicalFacet.attributes[level],\n            value: level === 0 ? segment : [map[map.length - 1].value, segment].join(separator)\n          });\n        }, []);\n        filtersMap.forEach(function (filter, level) {\n          var params = requestBuilder._getDisjunctiveFacetSearchParams(state, filter.attribute, level === 0);\n\n          // Keep facet filters unrelated to current hierarchical attributes\n          function hasHierarchicalFacetFilter(value) {\n            return hierarchicalFacet.attributes.some(function (attribute) {\n              return attribute === value.split(':')[0];\n            });\n          }\n          var filteredFacetFilters = (params.facetFilters || []).reduce(function (acc, facetFilter) {\n            if (Array.isArray(facetFilter)) {\n              var filtered = facetFilter.filter(function (filterValue) {\n                return !hasHierarchicalFacetFilter(filterValue);\n              });\n              if (filtered.length > 0) {\n                acc.push(filtered);\n              }\n            }\n            if (typeof facetFilter === 'string' && !hasHierarchicalFacetFilter(facetFilter)) {\n              acc.push(facetFilter);\n            }\n            return acc;\n          }, []);\n          var parent = filtersMap[level - 1];\n          if (level > 0) {\n            params.facetFilters = filteredFacetFilters.concat(parent.attribute + ':' + parent.value);\n          } else {\n            params.facetFilters = filteredFacetFilters.length > 0 ? filteredFacetFilters : undefined;\n          }\n          queries.push({\n            indexName: index,\n            params: params\n          });\n        });\n      }\n    });\n    return queries;\n  },\n  /**\n   * Build search parameters used to fetch hits\n   * @private\n   * @return {object.<string, any>}\n   */\n  _getHitsSearchParams: function (state) {\n    var facets = state.facets.concat(state.disjunctiveFacets).concat(requestBuilder._getHitsHierarchicalFacetsAttributes(state));\n    var facetFilters = requestBuilder._getFacetFilters(state);\n    var numericFilters = requestBuilder._getNumericFilters(state);\n    var tagFilters = requestBuilder._getTagFilters(state);\n    var additionalParams = {\n      facets: facets.indexOf('*') > -1 ? ['*'] : facets,\n      tagFilters: tagFilters\n    };\n    if (facetFilters.length > 0) {\n      additionalParams.facetFilters = facetFilters;\n    }\n    if (numericFilters.length > 0) {\n      additionalParams.numericFilters = numericFilters;\n    }\n    return sortObject(merge({}, state.getQueryParams(), additionalParams));\n  },\n  /**\n   * Build search parameters used to fetch a disjunctive facet\n   * @private\n   * @param  {string} facet the associated facet name\n   * @param  {boolean} hierarchicalRootLevel ?? FIXME\n   * @return {object}\n   */\n  _getDisjunctiveFacetSearchParams: function (state, facet, hierarchicalRootLevel) {\n    var facetFilters = requestBuilder._getFacetFilters(state, facet, hierarchicalRootLevel);\n    var numericFilters = requestBuilder._getNumericFilters(state, facet);\n    var tagFilters = requestBuilder._getTagFilters(state);\n    var additionalParams = {\n      hitsPerPage: 0,\n      page: 0,\n      analytics: false,\n      clickAnalytics: false\n    };\n    if (tagFilters.length > 0) {\n      additionalParams.tagFilters = tagFilters;\n    }\n    var hierarchicalFacet = state.getHierarchicalFacetByName(facet);\n    if (hierarchicalFacet) {\n      additionalParams.facets = requestBuilder._getDisjunctiveHierarchicalFacetAttribute(state, hierarchicalFacet, hierarchicalRootLevel);\n    } else {\n      additionalParams.facets = facet;\n    }\n    if (numericFilters.length > 0) {\n      additionalParams.numericFilters = numericFilters;\n    }\n    if (facetFilters.length > 0) {\n      additionalParams.facetFilters = facetFilters;\n    }\n    return sortObject(merge({}, state.getQueryParams(), additionalParams));\n  },\n  /**\n   * Return the numeric filters in an algolia request fashion\n   * @private\n   * @param {string} [facetName] the name of the attribute for which the filters should be excluded\n   * @return {string[]} the numeric filters in the algolia format\n   */\n  _getNumericFilters: function (state, facetName) {\n    if (state.numericFilters) {\n      return state.numericFilters;\n    }\n    var numericFilters = [];\n    Object.keys(state.numericRefinements).forEach(function (attribute) {\n      var operators = state.numericRefinements[attribute] || {};\n      Object.keys(operators).forEach(function (operator) {\n        var values = operators[operator] || [];\n        if (facetName !== attribute) {\n          values.forEach(function (value) {\n            if (Array.isArray(value)) {\n              var vs = value.map(function (v) {\n                return attribute + operator + v;\n              });\n              numericFilters.push(vs);\n            } else {\n              numericFilters.push(attribute + operator + value);\n            }\n          });\n        }\n      });\n    });\n    return numericFilters;\n  },\n  /**\n   * Return the tags filters depending\n   * @private\n   * @return {string}\n   */\n  _getTagFilters: function (state) {\n    if (state.tagFilters) {\n      return state.tagFilters;\n    }\n    return state.tagRefinements.join(',');\n  },\n  /**\n   * Build facetFilters parameter based on current refinements. The array returned\n   * contains strings representing the facet filters in the algolia format.\n   * @private\n   * @param  {string} [facet] if set, the current disjunctive facet\n   * @return {array.<string>}\n   */\n  _getFacetFilters: function (state, facet, hierarchicalRootLevel) {\n    var facetFilters = [];\n    var facetsRefinements = state.facetsRefinements || {};\n    Object.keys(facetsRefinements).forEach(function (facetName) {\n      var facetValues = facetsRefinements[facetName] || [];\n      facetValues.forEach(function (facetValue) {\n        facetFilters.push(facetName + ':' + facetValue);\n      });\n    });\n    var facetsExcludes = state.facetsExcludes || {};\n    Object.keys(facetsExcludes).forEach(function (facetName) {\n      var facetValues = facetsExcludes[facetName] || [];\n      facetValues.forEach(function (facetValue) {\n        facetFilters.push(facetName + ':-' + facetValue);\n      });\n    });\n    var disjunctiveFacetsRefinements = state.disjunctiveFacetsRefinements || {};\n    Object.keys(disjunctiveFacetsRefinements).forEach(function (facetName) {\n      var facetValues = disjunctiveFacetsRefinements[facetName] || [];\n      if (facetName === facet || !facetValues || facetValues.length === 0) {\n        return;\n      }\n      var orFilters = [];\n      facetValues.forEach(function (facetValue) {\n        orFilters.push(facetName + ':' + facetValue);\n      });\n      facetFilters.push(orFilters);\n    });\n    var hierarchicalFacetsRefinements = state.hierarchicalFacetsRefinements || {};\n    Object.keys(hierarchicalFacetsRefinements).forEach(function (facetName) {\n      var facetValues = hierarchicalFacetsRefinements[facetName] || [];\n      var facetValue = facetValues[0];\n      if (facetValue === undefined) {\n        return;\n      }\n      var hierarchicalFacet = state.getHierarchicalFacetByName(facetName);\n      var separator = state._getHierarchicalFacetSeparator(hierarchicalFacet);\n      var rootPath = state._getHierarchicalRootPath(hierarchicalFacet);\n      var attributeToRefine;\n      var attributesIndex;\n\n      // we ask for parent facet values only when the `facet` is the current hierarchical facet\n      if (facet === facetName) {\n        // if we are at the root level already, no need to ask for facet values, we get them from\n        // the hits query\n        if (facetValue.indexOf(separator) === -1 || !rootPath && hierarchicalRootLevel === true || rootPath && rootPath.split(separator).length === facetValue.split(separator).length) {\n          return;\n        }\n        if (!rootPath) {\n          attributesIndex = facetValue.split(separator).length - 2;\n          facetValue = facetValue.slice(0, facetValue.lastIndexOf(separator));\n        } else {\n          attributesIndex = rootPath.split(separator).length - 1;\n          facetValue = rootPath;\n        }\n        attributeToRefine = hierarchicalFacet.attributes[attributesIndex];\n      } else {\n        attributesIndex = facetValue.split(separator).length - 1;\n        attributeToRefine = hierarchicalFacet.attributes[attributesIndex];\n      }\n      if (attributeToRefine) {\n        facetFilters.push([attributeToRefine + ':' + facetValue]);\n      }\n    });\n    return facetFilters;\n  },\n  _getHitsHierarchicalFacetsAttributes: function (state) {\n    var out = [];\n    return state.hierarchicalFacets.reduce(\n    // ask for as much levels as there's hierarchical refinements\n    function getHitsAttributesForHierarchicalFacet(allAttributes, hierarchicalFacet) {\n      var hierarchicalRefinement = state.getHierarchicalRefinement(hierarchicalFacet.name)[0];\n\n      // if no refinement, ask for root level\n      if (!hierarchicalRefinement) {\n        allAttributes.push(hierarchicalFacet.attributes[0]);\n        return allAttributes;\n      }\n      var separator = state._getHierarchicalFacetSeparator(hierarchicalFacet);\n      var level = hierarchicalRefinement.split(separator).length;\n      var newAttributes = hierarchicalFacet.attributes.slice(0, level + 1);\n      return allAttributes.concat(newAttributes);\n    }, out);\n  },\n  _getDisjunctiveHierarchicalFacetAttribute: function (state, hierarchicalFacet, rootLevel) {\n    var separator = state._getHierarchicalFacetSeparator(hierarchicalFacet);\n    if (rootLevel === true) {\n      var rootPath = state._getHierarchicalRootPath(hierarchicalFacet);\n      var attributeIndex = 0;\n      if (rootPath) {\n        attributeIndex = rootPath.split(separator).length;\n      }\n      return [hierarchicalFacet.attributes[attributeIndex]];\n    }\n    var hierarchicalRefinement = state.getHierarchicalRefinement(hierarchicalFacet.name)[0] || '';\n    // if refinement is 'beers > IPA > Flying dog',\n    // then we want `facets: ['beers > IPA']` as disjunctive facet (parent level values)\n\n    var parentLevel = hierarchicalRefinement.split(separator).length - 1;\n    return hierarchicalFacet.attributes.slice(0, parentLevel + 1);\n  },\n  getSearchForFacetQuery: function (facetName, query, maxFacetHits, state) {\n    var stateForSearchForFacetValues = state.isDisjunctiveFacet(facetName) ? state.clearRefinements(facetName) : state;\n    var searchForFacetSearchParameters = {\n      facetQuery: query,\n      facetName: facetName\n    };\n    if (typeof maxFacetHits === 'number') {\n      searchForFacetSearchParameters.maxFacetHits = maxFacetHits;\n    }\n    return sortObject(merge({}, requestBuilder._getHitsSearchParams(stateForSearchForFacetValues), searchForFacetSearchParameters));\n  }\n};\nmodule.exports = requestBuilder;","map":{"version":3,"names":["merge","require","sortObject","obj","Object","keys","sort","a","b","localeCompare","reduce","acc","curr","requestBuilder","_getQueries","getQueries","index","state","queries","push","indexName","params","_getHitsSearchParams","getRefinedDisjunctiveFacets","forEach","refinedFacet","_getDisjunctiveFacetSearchParams","getRefinedHierarchicalFacets","hierarchicalFacet","getHierarchicalFacetByName","currentRefinement","getHierarchicalRefinement","separator","_getHierarchicalFacetSeparator","length","split","filtersMap","slice","createFiltersMap","map","segment","level","concat","attribute","attributes","value","join","filter","hasHierarchicalFacetFilter","some","filteredFacetFilters","facetFilters","facetFilter","Array","isArray","filtered","filterValue","parent","undefined","facets","disjunctiveFacets","_getHitsHierarchicalFacetsAttributes","_getFacetFilters","numericFilters","_getNumericFilters","tagFilters","_getTagFilters","additionalParams","indexOf","getQueryParams","facet","hierarchicalRootLevel","hitsPerPage","page","analytics","clickAnalytics","_getDisjunctiveHierarchicalFacetAttribute","facetName","numericRefinements","operators","operator","values","vs","v","tagRefinements","facetsRefinements","facetValues","facetValue","facetsExcludes","disjunctiveFacetsRefinements","orFilters","hierarchicalFacetsRefinements","rootPath","_getHierarchicalRootPath","attributeToRefine","attributesIndex","lastIndexOf","out","hierarchicalFacets","getHitsAttributesForHierarchicalFacet","allAttributes","hierarchicalRefinement","name","newAttributes","rootLevel","attributeIndex","parentLevel","getSearchForFacetQuery","query","maxFacetHits","stateForSearchForFacetValues","isDisjunctiveFacet","clearRefinements","searchForFacetSearchParameters","facetQuery","module","exports"],"sources":["/Users/amandawinkler/Downloads/algolia-instantsearch-react-geo/node_modules/algoliasearch-helper/src/requestBuilder.js"],"sourcesContent":["'use strict';\n\nvar merge = require('./functions/merge');\n\nfunction sortObject(obj) {\n  return Object.keys(obj)\n    .sort(function(a, b) {\n      return a.localeCompare(b);\n    })\n    .reduce(function(acc, curr) {\n      acc[curr] = obj[curr];\n      return acc;\n    }, {});\n}\n\nvar requestBuilder = {\n  /**\n   * Get all the queries to send to the client, those queries can used directly\n   * with the Algolia client.\n   * @private\n   * @return {object[]} The queries\n   */\n  _getQueries: function getQueries(index, state) {\n    var queries = [];\n\n    // One query for the hits\n    queries.push({\n      indexName: index,\n      params: requestBuilder._getHitsSearchParams(state)\n    });\n\n    // One for each disjunctive facets\n    state.getRefinedDisjunctiveFacets().forEach(function(refinedFacet) {\n      queries.push({\n        indexName: index,\n        params: requestBuilder._getDisjunctiveFacetSearchParams(state, refinedFacet)\n      });\n    });\n\n    // More to get the parent levels of the hierarchical facets when refined\n    state.getRefinedHierarchicalFacets().forEach(function(refinedFacet) {\n      var hierarchicalFacet = state.getHierarchicalFacetByName(refinedFacet);\n      var currentRefinement = state.getHierarchicalRefinement(refinedFacet);\n      var separator = state._getHierarchicalFacetSeparator(hierarchicalFacet);\n\n      // If we are deeper than level 0 (starting from `beer > IPA`)\n      // we want to get all parent values\n      if (currentRefinement.length > 0 && currentRefinement[0].split(separator).length > 1) {\n        // We generate a map of the filters we will use for our facet values queries\n        var filtersMap = currentRefinement[0].split(separator).slice(0, -1).reduce(\n          function createFiltersMap(map, segment, level) {\n            return map.concat({\n              attribute: hierarchicalFacet.attributes[level],\n              value: level === 0\n                ? segment\n                : [map[map.length - 1].value, segment].join(separator)\n            });\n          }\n        , []);\n\n        filtersMap.forEach(function(filter, level) {\n          var params = requestBuilder._getDisjunctiveFacetSearchParams(\n            state,\n            filter.attribute,\n            level === 0\n          );\n\n          // Keep facet filters unrelated to current hierarchical attributes\n          function hasHierarchicalFacetFilter(value) {\n            return hierarchicalFacet.attributes.some(function(attribute) {\n              return attribute === value.split(':')[0];\n            });\n          }\n\n          var filteredFacetFilters = (params.facetFilters || []).reduce(function(acc, facetFilter) {\n            if (Array.isArray(facetFilter)) {\n              var filtered = facetFilter.filter(function(filterValue) {\n                return !hasHierarchicalFacetFilter(filterValue);\n              });\n\n              if (filtered.length > 0) {\n                acc.push(filtered);\n              }\n            }\n\n            if (typeof facetFilter === 'string' && !hasHierarchicalFacetFilter(facetFilter)) {\n              acc.push(facetFilter);\n            }\n\n            return acc;\n          }, []);\n\n          var parent = filtersMap[level - 1];\n          if (level > 0) {\n            params.facetFilters = filteredFacetFilters.concat(parent.attribute + ':' + parent.value);\n          } else {\n            params.facetFilters = filteredFacetFilters.length > 0 ? filteredFacetFilters : undefined;\n          }\n\n          queries.push({indexName: index, params: params});\n        });\n      }\n    });\n\n    return queries;\n  },\n\n  /**\n   * Build search parameters used to fetch hits\n   * @private\n   * @return {object.<string, any>}\n   */\n  _getHitsSearchParams: function(state) {\n    var facets = state.facets\n      .concat(state.disjunctiveFacets)\n      .concat(requestBuilder._getHitsHierarchicalFacetsAttributes(state));\n\n\n    var facetFilters = requestBuilder._getFacetFilters(state);\n    var numericFilters = requestBuilder._getNumericFilters(state);\n    var tagFilters = requestBuilder._getTagFilters(state);\n    var additionalParams = {\n      facets: facets.indexOf('*') > -1 ? ['*'] : facets,\n      tagFilters: tagFilters\n    };\n\n    if (facetFilters.length > 0) {\n      additionalParams.facetFilters = facetFilters;\n    }\n\n    if (numericFilters.length > 0) {\n      additionalParams.numericFilters = numericFilters;\n    }\n\n    return sortObject(merge({}, state.getQueryParams(), additionalParams));\n  },\n\n  /**\n   * Build search parameters used to fetch a disjunctive facet\n   * @private\n   * @param  {string} facet the associated facet name\n   * @param  {boolean} hierarchicalRootLevel ?? FIXME\n   * @return {object}\n   */\n  _getDisjunctiveFacetSearchParams: function(state, facet, hierarchicalRootLevel) {\n    var facetFilters = requestBuilder._getFacetFilters(state, facet, hierarchicalRootLevel);\n    var numericFilters = requestBuilder._getNumericFilters(state, facet);\n    var tagFilters = requestBuilder._getTagFilters(state);\n    var additionalParams = {\n      hitsPerPage: 0,\n      page: 0,\n      analytics: false,\n      clickAnalytics: false\n    };\n\n    if (tagFilters.length > 0) {\n      additionalParams.tagFilters = tagFilters;\n    }\n\n    var hierarchicalFacet = state.getHierarchicalFacetByName(facet);\n\n    if (hierarchicalFacet) {\n      additionalParams.facets = requestBuilder._getDisjunctiveHierarchicalFacetAttribute(\n        state,\n        hierarchicalFacet,\n        hierarchicalRootLevel\n      );\n    } else {\n      additionalParams.facets = facet;\n    }\n\n    if (numericFilters.length > 0) {\n      additionalParams.numericFilters = numericFilters;\n    }\n\n    if (facetFilters.length > 0) {\n      additionalParams.facetFilters = facetFilters;\n    }\n\n    return sortObject(merge({}, state.getQueryParams(), additionalParams));\n  },\n\n  /**\n   * Return the numeric filters in an algolia request fashion\n   * @private\n   * @param {string} [facetName] the name of the attribute for which the filters should be excluded\n   * @return {string[]} the numeric filters in the algolia format\n   */\n  _getNumericFilters: function(state, facetName) {\n    if (state.numericFilters) {\n      return state.numericFilters;\n    }\n\n    var numericFilters = [];\n\n    Object.keys(state.numericRefinements).forEach(function(attribute) {\n      var operators = state.numericRefinements[attribute] || {};\n      Object.keys(operators).forEach(function(operator) {\n        var values = operators[operator] || [];\n        if (facetName !== attribute) {\n          values.forEach(function(value) {\n            if (Array.isArray(value)) {\n              var vs = value.map(function(v) {\n                return attribute + operator + v;\n              });\n              numericFilters.push(vs);\n            } else {\n              numericFilters.push(attribute + operator + value);\n            }\n          });\n        }\n      });\n    });\n\n    return numericFilters;\n  },\n\n  /**\n   * Return the tags filters depending\n   * @private\n   * @return {string}\n   */\n  _getTagFilters: function(state) {\n    if (state.tagFilters) {\n      return state.tagFilters;\n    }\n\n    return state.tagRefinements.join(',');\n  },\n\n\n  /**\n   * Build facetFilters parameter based on current refinements. The array returned\n   * contains strings representing the facet filters in the algolia format.\n   * @private\n   * @param  {string} [facet] if set, the current disjunctive facet\n   * @return {array.<string>}\n   */\n  _getFacetFilters: function(state, facet, hierarchicalRootLevel) {\n    var facetFilters = [];\n\n    var facetsRefinements = state.facetsRefinements || {};\n    Object.keys(facetsRefinements).forEach(function(facetName) {\n      var facetValues = facetsRefinements[facetName] || [];\n      facetValues.forEach(function(facetValue) {\n        facetFilters.push(facetName + ':' + facetValue);\n      });\n    });\n\n    var facetsExcludes = state.facetsExcludes || {};\n    Object.keys(facetsExcludes).forEach(function(facetName) {\n      var facetValues = facetsExcludes[facetName] || [];\n      facetValues.forEach(function(facetValue) {\n        facetFilters.push(facetName + ':-' + facetValue);\n      });\n    });\n\n    var disjunctiveFacetsRefinements = state.disjunctiveFacetsRefinements || {};\n    Object.keys(disjunctiveFacetsRefinements).forEach(function(facetName) {\n      var facetValues = disjunctiveFacetsRefinements[facetName] || [];\n      if (facetName === facet || !facetValues || facetValues.length === 0) {\n        return;\n      }\n      var orFilters = [];\n\n      facetValues.forEach(function(facetValue) {\n        orFilters.push(facetName + ':' + facetValue);\n      });\n\n      facetFilters.push(orFilters);\n    });\n\n    var hierarchicalFacetsRefinements = state.hierarchicalFacetsRefinements || {};\n    Object.keys(hierarchicalFacetsRefinements).forEach(function(facetName) {\n      var facetValues = hierarchicalFacetsRefinements[facetName] || [];\n      var facetValue = facetValues[0];\n\n      if (facetValue === undefined) {\n        return;\n      }\n\n      var hierarchicalFacet = state.getHierarchicalFacetByName(facetName);\n      var separator = state._getHierarchicalFacetSeparator(hierarchicalFacet);\n      var rootPath = state._getHierarchicalRootPath(hierarchicalFacet);\n      var attributeToRefine;\n      var attributesIndex;\n\n      // we ask for parent facet values only when the `facet` is the current hierarchical facet\n      if (facet === facetName) {\n        // if we are at the root level already, no need to ask for facet values, we get them from\n        // the hits query\n        if (facetValue.indexOf(separator) === -1 || (!rootPath && hierarchicalRootLevel === true) ||\n          (rootPath && rootPath.split(separator).length === facetValue.split(separator).length)) {\n          return;\n        }\n\n        if (!rootPath) {\n          attributesIndex = facetValue.split(separator).length - 2;\n          facetValue = facetValue.slice(0, facetValue.lastIndexOf(separator));\n        } else {\n          attributesIndex = rootPath.split(separator).length - 1;\n          facetValue = rootPath;\n        }\n\n        attributeToRefine = hierarchicalFacet.attributes[attributesIndex];\n      } else {\n        attributesIndex = facetValue.split(separator).length - 1;\n\n        attributeToRefine = hierarchicalFacet.attributes[attributesIndex];\n      }\n\n      if (attributeToRefine) {\n        facetFilters.push([attributeToRefine + ':' + facetValue]);\n      }\n    });\n\n    return facetFilters;\n  },\n\n  _getHitsHierarchicalFacetsAttributes: function(state) {\n    var out = [];\n\n    return state.hierarchicalFacets.reduce(\n      // ask for as much levels as there's hierarchical refinements\n      function getHitsAttributesForHierarchicalFacet(allAttributes, hierarchicalFacet) {\n        var hierarchicalRefinement = state.getHierarchicalRefinement(hierarchicalFacet.name)[0];\n\n        // if no refinement, ask for root level\n        if (!hierarchicalRefinement) {\n          allAttributes.push(hierarchicalFacet.attributes[0]);\n          return allAttributes;\n        }\n\n        var separator = state._getHierarchicalFacetSeparator(hierarchicalFacet);\n        var level = hierarchicalRefinement.split(separator).length;\n        var newAttributes = hierarchicalFacet.attributes.slice(0, level + 1);\n\n        return allAttributes.concat(newAttributes);\n      }, out);\n  },\n\n  _getDisjunctiveHierarchicalFacetAttribute: function(state, hierarchicalFacet, rootLevel) {\n    var separator = state._getHierarchicalFacetSeparator(hierarchicalFacet);\n    if (rootLevel === true) {\n      var rootPath = state._getHierarchicalRootPath(hierarchicalFacet);\n      var attributeIndex = 0;\n\n      if (rootPath) {\n        attributeIndex = rootPath.split(separator).length;\n      }\n      return [hierarchicalFacet.attributes[attributeIndex]];\n    }\n\n    var hierarchicalRefinement = state.getHierarchicalRefinement(hierarchicalFacet.name)[0] || '';\n    // if refinement is 'beers > IPA > Flying dog',\n    // then we want `facets: ['beers > IPA']` as disjunctive facet (parent level values)\n\n    var parentLevel = hierarchicalRefinement.split(separator).length - 1;\n    return hierarchicalFacet.attributes.slice(0, parentLevel + 1);\n  },\n\n  getSearchForFacetQuery: function(facetName, query, maxFacetHits, state) {\n    var stateForSearchForFacetValues = state.isDisjunctiveFacet(facetName) ?\n      state.clearRefinements(facetName) :\n      state;\n    var searchForFacetSearchParameters = {\n      facetQuery: query,\n      facetName: facetName\n    };\n    if (typeof maxFacetHits === 'number') {\n      searchForFacetSearchParameters.maxFacetHits = maxFacetHits;\n    }\n    return sortObject(merge(\n      {},\n      requestBuilder._getHitsSearchParams(stateForSearchForFacetValues),\n      searchForFacetSearchParameters\n    ));\n  }\n};\n\nmodule.exports = requestBuilder;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}