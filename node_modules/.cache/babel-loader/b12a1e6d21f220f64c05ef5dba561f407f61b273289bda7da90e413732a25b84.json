{"ast":null,"code":"function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\nvar _excluded = [\"defaultRefinement\"];\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return _typeof(key) === \"symbol\" ? key : String(key);\n}\nfunction _toPrimitive(input, hint) {\n  if (_typeof(input) !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (_typeof(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n  return target;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\nimport { objectHasKeys } from \"../core/utils.js\";\nimport createConnector from \"../core/createConnector.js\";\nimport { getResults, getCurrentRefinementValue, getIndexId, refineValue, cleanUpValue } from \"../core/indexUtils.js\";\n\n/**\n * The GeoSearch connector provides the logic to build a widget that will display the results on a map.\n * It also provides a way to search for results based on their position. The connector provides function to manage the search experience (search on map interaction).\n * @name connectGeoSearch\n * @kind connector\n * @requirements Note that the GeoSearch connector uses the [geosearch](https://www.algolia.com/doc/guides/searching/geo-search) capabilities of Algolia.\n * Your hits **must** have a `_geoloc` attribute in order to be passed to the rendering function. Currently, the feature is not compatible with multiple values in the `_geoloc` attribute\n * (e.g. a restaurant with multiple locations). In that case you can duplicate your records and use the [distinct](https://www.algolia.com/doc/guides/ranking/distinct) feature of Algolia to only retrieve unique results.\n * @propType {{ northEast: { lat: number, lng: number }, southWest: { lat: number, lng: number } }} [defaultRefinement] - Default search state of the widget containing the bounds for the map\n * @providedPropType {function({ northEast: { lat: number, lng: number }, southWest: { lat: number, lng: number } })} refine - a function to toggle the refinement\n * @providedPropType {function} createURL - a function to generate a URL for the corresponding search state\n * @providedPropType {array.<object>} hits - the records that matched the search\n * @providedPropType {boolean} isRefinedWithMap - true if the current refinement is set with the map bounds\n * @providedPropType {{ northEast: { lat: number, lng: number }, southWest: { lat: number, lng: number } }} [currentRefinement] - the refinement currently applied\n * @providedPropType {{ lat: number, lng: number }} [position] - the position of the search\n */\n\n// To control the map with an external widget the other widget\n// **must** write the value in the attribute `aroundLatLng`\nvar getBoundingBoxId = function getBoundingBoxId() {\n  return 'boundingBox';\n};\nvar getAroundLatLngId = function getAroundLatLngId() {\n  return 'aroundLatLng';\n};\nvar getConfigureAroundLatLngId = function getConfigureAroundLatLngId() {\n  return 'configure.aroundLatLng';\n};\nvar currentRefinementToString = function currentRefinementToString(currentRefinement) {\n  return [currentRefinement.northEast.lat, currentRefinement.northEast.lng, currentRefinement.southWest.lat, currentRefinement.southWest.lng].join();\n};\nvar stringToCurrentRefinement = function stringToCurrentRefinement(value) {\n  var values = value.split(',');\n  return {\n    northEast: {\n      lat: parseFloat(values[0]),\n      lng: parseFloat(values[1])\n    },\n    southWest: {\n      lat: parseFloat(values[2]),\n      lng: parseFloat(values[3])\n    }\n  };\n};\nvar latLngRegExp = /^(-?\\d+(?:\\.\\d+)?),\\s*(-?\\d+(?:\\.\\d+)?)$/;\nvar stringToPosition = function stringToPosition(value) {\n  var pattern = value.match(latLngRegExp);\n  return {\n    lat: parseFloat(pattern[1]),\n    lng: parseFloat(pattern[2])\n  };\n};\nvar getCurrentRefinement = function getCurrentRefinement(props, searchState, context) {\n  var refinement = getCurrentRefinementValue(props, searchState, context, getBoundingBoxId(), {});\n  if (!objectHasKeys(refinement)) {\n    return;\n  }\n\n  // eslint-disable-next-line consistent-return\n  return {\n    northEast: {\n      lat: parseFloat(refinement.northEast.lat),\n      lng: parseFloat(refinement.northEast.lng)\n    },\n    southWest: {\n      lat: parseFloat(refinement.southWest.lat),\n      lng: parseFloat(refinement.southWest.lng)\n    }\n  };\n};\nvar getCurrentPosition = function getCurrentPosition(props, searchState, context) {\n  var defaultRefinement = props.defaultRefinement,\n    propsWithoutDefaultRefinement = _objectWithoutProperties(props, _excluded);\n  var aroundLatLng = getCurrentRefinementValue(propsWithoutDefaultRefinement, searchState, context, getAroundLatLngId());\n  if (!aroundLatLng) {\n    // Fallback on `configure.aroundLatLng`\n    var configureAroundLatLng = getCurrentRefinementValue(propsWithoutDefaultRefinement, searchState, context, getConfigureAroundLatLngId());\n    return configureAroundLatLng && stringToPosition(configureAroundLatLng);\n  }\n  return aroundLatLng;\n};\nvar _refine = function refine(searchState, nextValue, context) {\n  var resetPage = true;\n  var nextRefinement = _defineProperty({}, getBoundingBoxId(), nextValue);\n  return refineValue(searchState, nextRefinement, context, resetPage);\n};\nexport default createConnector({\n  displayName: 'AlgoliaGeoSearch',\n  $$type: 'ais.geoSearch',\n  getProvidedProps: function getProvidedProps(props, searchState, searchResults) {\n    var context = {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    };\n    var results = getResults(searchResults, context);\n\n    // We read it from both because the SearchParameters & the searchState are not always\n    // in sync. When we set the refinement the searchState is used but when we clear the refinement\n    // the SearchParameters is used. In the first case when we render, the results are not there\n    // so we can't find the value from the results. The most up to date value is the searchState.\n    // But when we clear the refinement the searchState is immediately cleared even when the items\n    // retrieved are still the one from the previous query with the bounding box. It leads to some\n    // issue with the position of the map. We should rely on 1 source of truth or at least always\n    // be sync.\n\n    var currentRefinementFromSearchState = getCurrentRefinement(props, searchState, context);\n    var currentRefinementFromSearchParameters = results && results._state.insideBoundingBox && stringToCurrentRefinement(results._state.insideBoundingBox) || undefined;\n    var currentPositionFromSearchState = getCurrentPosition(props, searchState, context);\n    var currentPositionFromSearchParameters = results && results._state.aroundLatLng && stringToPosition(results._state.aroundLatLng) || undefined;\n    var currentRefinement = currentRefinementFromSearchState || currentRefinementFromSearchParameters;\n    var position = currentPositionFromSearchState || currentPositionFromSearchParameters;\n    return {\n      hits: !results ? [] : results.hits.filter(function (_) {\n        return Boolean(_._geoloc);\n      }),\n      isRefinedWithMap: Boolean(currentRefinement),\n      currentRefinement: currentRefinement,\n      position: position\n    };\n  },\n  refine: function refine(props, searchState, nextValue) {\n    return _refine(searchState, nextValue, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    });\n  },\n  getSearchParameters: function getSearchParameters(searchParameters, props, searchState) {\n    var currentRefinement = getCurrentRefinement(props, searchState, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    });\n    if (!currentRefinement) {\n      return searchParameters;\n    }\n    return searchParameters.setQueryParameter('insideBoundingBox', currentRefinementToString(currentRefinement));\n  },\n  cleanUp: function cleanUp(props, searchState) {\n    return cleanUpValue(searchState, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    }, getBoundingBoxId());\n  },\n  getMetadata: function getMetadata(props, searchState) {\n    var items = [];\n    var id = getBoundingBoxId();\n    var context = {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    };\n    var index = getIndexId(context);\n    var nextRefinement = {};\n    var currentRefinement = getCurrentRefinement(props, searchState, context);\n    if (currentRefinement) {\n      items.push({\n        label: \"\".concat(id, \": \").concat(currentRefinementToString(currentRefinement)),\n        value: function value(nextState) {\n          return _refine(nextState, nextRefinement, context);\n        },\n        currentRefinement: currentRefinement\n      });\n    }\n    return {\n      id: id,\n      index: index,\n      items: items\n    };\n  },\n  shouldComponentUpdate: function shouldComponentUpdate() {\n    return true;\n  }\n});","map":{"version":3,"names":["_typeof","obj","Symbol","iterator","constructor","prototype","_excluded","_defineProperty","key","value","_toPropertyKey","Object","defineProperty","enumerable","configurable","writable","arg","_toPrimitive","String","input","hint","prim","toPrimitive","undefined","res","call","TypeError","Number","_objectWithoutProperties","source","excluded","target","_objectWithoutPropertiesLoose","i","getOwnPropertySymbols","sourceSymbolKeys","length","indexOf","propertyIsEnumerable","sourceKeys","keys","objectHasKeys","createConnector","getResults","getCurrentRefinementValue","getIndexId","refineValue","cleanUpValue","getBoundingBoxId","getAroundLatLngId","getConfigureAroundLatLngId","currentRefinementToString","currentRefinement","northEast","lat","lng","southWest","join","stringToCurrentRefinement","values","split","parseFloat","latLngRegExp","stringToPosition","pattern","match","getCurrentRefinement","props","searchState","context","refinement","getCurrentPosition","defaultRefinement","propsWithoutDefaultRefinement","aroundLatLng","configureAroundLatLng","_refine","refine","nextValue","resetPage","nextRefinement","displayName","$$type","getProvidedProps","searchResults","ais","contextValue","multiIndexContext","indexContextValue","results","currentRefinementFromSearchState","currentRefinementFromSearchParameters","_state","insideBoundingBox","currentPositionFromSearchState","currentPositionFromSearchParameters","position","hits","filter","_","Boolean","_geoloc","isRefinedWithMap","getSearchParameters","searchParameters","setQueryParameter","cleanUp","getMetadata","items","id","index","push","label","concat","nextState","shouldComponentUpdate"],"sources":["/Users/amandawinkler/Desktop/algolia-instantsearch-react-geo/node_modules/react-instantsearch-core/dist/es/connectors/connectGeoSearch.js"],"sourcesContent":["function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nvar _excluded = [\"defaultRefinement\"];\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\nimport { objectHasKeys } from \"../core/utils.js\";\nimport createConnector from \"../core/createConnector.js\";\nimport { getResults, getCurrentRefinementValue, getIndexId, refineValue, cleanUpValue } from \"../core/indexUtils.js\";\n\n/**\n * The GeoSearch connector provides the logic to build a widget that will display the results on a map.\n * It also provides a way to search for results based on their position. The connector provides function to manage the search experience (search on map interaction).\n * @name connectGeoSearch\n * @kind connector\n * @requirements Note that the GeoSearch connector uses the [geosearch](https://www.algolia.com/doc/guides/searching/geo-search) capabilities of Algolia.\n * Your hits **must** have a `_geoloc` attribute in order to be passed to the rendering function. Currently, the feature is not compatible with multiple values in the `_geoloc` attribute\n * (e.g. a restaurant with multiple locations). In that case you can duplicate your records and use the [distinct](https://www.algolia.com/doc/guides/ranking/distinct) feature of Algolia to only retrieve unique results.\n * @propType {{ northEast: { lat: number, lng: number }, southWest: { lat: number, lng: number } }} [defaultRefinement] - Default search state of the widget containing the bounds for the map\n * @providedPropType {function({ northEast: { lat: number, lng: number }, southWest: { lat: number, lng: number } })} refine - a function to toggle the refinement\n * @providedPropType {function} createURL - a function to generate a URL for the corresponding search state\n * @providedPropType {array.<object>} hits - the records that matched the search\n * @providedPropType {boolean} isRefinedWithMap - true if the current refinement is set with the map bounds\n * @providedPropType {{ northEast: { lat: number, lng: number }, southWest: { lat: number, lng: number } }} [currentRefinement] - the refinement currently applied\n * @providedPropType {{ lat: number, lng: number }} [position] - the position of the search\n */\n\n// To control the map with an external widget the other widget\n// **must** write the value in the attribute `aroundLatLng`\nvar getBoundingBoxId = function getBoundingBoxId() {\n  return 'boundingBox';\n};\nvar getAroundLatLngId = function getAroundLatLngId() {\n  return 'aroundLatLng';\n};\nvar getConfigureAroundLatLngId = function getConfigureAroundLatLngId() {\n  return 'configure.aroundLatLng';\n};\nvar currentRefinementToString = function currentRefinementToString(currentRefinement) {\n  return [currentRefinement.northEast.lat, currentRefinement.northEast.lng, currentRefinement.southWest.lat, currentRefinement.southWest.lng].join();\n};\nvar stringToCurrentRefinement = function stringToCurrentRefinement(value) {\n  var values = value.split(',');\n  return {\n    northEast: {\n      lat: parseFloat(values[0]),\n      lng: parseFloat(values[1])\n    },\n    southWest: {\n      lat: parseFloat(values[2]),\n      lng: parseFloat(values[3])\n    }\n  };\n};\nvar latLngRegExp = /^(-?\\d+(?:\\.\\d+)?),\\s*(-?\\d+(?:\\.\\d+)?)$/;\nvar stringToPosition = function stringToPosition(value) {\n  var pattern = value.match(latLngRegExp);\n  return {\n    lat: parseFloat(pattern[1]),\n    lng: parseFloat(pattern[2])\n  };\n};\nvar getCurrentRefinement = function getCurrentRefinement(props, searchState, context) {\n  var refinement = getCurrentRefinementValue(props, searchState, context, getBoundingBoxId(), {});\n  if (!objectHasKeys(refinement)) {\n    return;\n  }\n\n  // eslint-disable-next-line consistent-return\n  return {\n    northEast: {\n      lat: parseFloat(refinement.northEast.lat),\n      lng: parseFloat(refinement.northEast.lng)\n    },\n    southWest: {\n      lat: parseFloat(refinement.southWest.lat),\n      lng: parseFloat(refinement.southWest.lng)\n    }\n  };\n};\nvar getCurrentPosition = function getCurrentPosition(props, searchState, context) {\n  var defaultRefinement = props.defaultRefinement,\n    propsWithoutDefaultRefinement = _objectWithoutProperties(props, _excluded);\n  var aroundLatLng = getCurrentRefinementValue(propsWithoutDefaultRefinement, searchState, context, getAroundLatLngId());\n  if (!aroundLatLng) {\n    // Fallback on `configure.aroundLatLng`\n    var configureAroundLatLng = getCurrentRefinementValue(propsWithoutDefaultRefinement, searchState, context, getConfigureAroundLatLngId());\n    return configureAroundLatLng && stringToPosition(configureAroundLatLng);\n  }\n  return aroundLatLng;\n};\nvar _refine = function refine(searchState, nextValue, context) {\n  var resetPage = true;\n  var nextRefinement = _defineProperty({}, getBoundingBoxId(), nextValue);\n  return refineValue(searchState, nextRefinement, context, resetPage);\n};\nexport default createConnector({\n  displayName: 'AlgoliaGeoSearch',\n  $$type: 'ais.geoSearch',\n  getProvidedProps: function getProvidedProps(props, searchState, searchResults) {\n    var context = {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    };\n    var results = getResults(searchResults, context);\n\n    // We read it from both because the SearchParameters & the searchState are not always\n    // in sync. When we set the refinement the searchState is used but when we clear the refinement\n    // the SearchParameters is used. In the first case when we render, the results are not there\n    // so we can't find the value from the results. The most up to date value is the searchState.\n    // But when we clear the refinement the searchState is immediately cleared even when the items\n    // retrieved are still the one from the previous query with the bounding box. It leads to some\n    // issue with the position of the map. We should rely on 1 source of truth or at least always\n    // be sync.\n\n    var currentRefinementFromSearchState = getCurrentRefinement(props, searchState, context);\n    var currentRefinementFromSearchParameters = results && results._state.insideBoundingBox && stringToCurrentRefinement(results._state.insideBoundingBox) || undefined;\n    var currentPositionFromSearchState = getCurrentPosition(props, searchState, context);\n    var currentPositionFromSearchParameters = results && results._state.aroundLatLng && stringToPosition(results._state.aroundLatLng) || undefined;\n    var currentRefinement = currentRefinementFromSearchState || currentRefinementFromSearchParameters;\n    var position = currentPositionFromSearchState || currentPositionFromSearchParameters;\n    return {\n      hits: !results ? [] : results.hits.filter(function (_) {\n        return Boolean(_._geoloc);\n      }),\n      isRefinedWithMap: Boolean(currentRefinement),\n      currentRefinement: currentRefinement,\n      position: position\n    };\n  },\n  refine: function refine(props, searchState, nextValue) {\n    return _refine(searchState, nextValue, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    });\n  },\n  getSearchParameters: function getSearchParameters(searchParameters, props, searchState) {\n    var currentRefinement = getCurrentRefinement(props, searchState, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    });\n    if (!currentRefinement) {\n      return searchParameters;\n    }\n    return searchParameters.setQueryParameter('insideBoundingBox', currentRefinementToString(currentRefinement));\n  },\n  cleanUp: function cleanUp(props, searchState) {\n    return cleanUpValue(searchState, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    }, getBoundingBoxId());\n  },\n  getMetadata: function getMetadata(props, searchState) {\n    var items = [];\n    var id = getBoundingBoxId();\n    var context = {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    };\n    var index = getIndexId(context);\n    var nextRefinement = {};\n    var currentRefinement = getCurrentRefinement(props, searchState, context);\n    if (currentRefinement) {\n      items.push({\n        label: \"\".concat(id, \": \").concat(currentRefinementToString(currentRefinement)),\n        value: function value(nextState) {\n          return _refine(nextState, nextRefinement, context);\n        },\n        currentRefinement: currentRefinement\n      });\n    }\n    return {\n      id: id,\n      index: index,\n      items: items\n    };\n  },\n  shouldComponentUpdate: function shouldComponentUpdate() {\n    return true;\n  }\n});"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}