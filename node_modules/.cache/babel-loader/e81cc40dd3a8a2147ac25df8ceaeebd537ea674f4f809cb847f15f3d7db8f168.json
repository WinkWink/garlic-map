{"ast":null,"code":"module.exports = AlgoliaSearchCore;\nvar errors = require('./errors');\nvar exitPromise = require('./exitPromise.js');\nvar IndexCore = require('./IndexCore.js');\nvar store = require('./store.js');\n\n// We will always put the API KEY in the JSON body in case of too long API KEY,\n// to avoid query string being too long and failing in various conditions (our server limit, browser limit,\n// proxies limit)\nvar MAX_API_KEY_LENGTH = 500;\nvar RESET_APP_DATA_TIMER = process.env.RESET_APP_DATA_TIMER && parseInt(process.env.RESET_APP_DATA_TIMER, 10) || 60 * 2 * 1000; // after 2 minutes reset to first host\n\n/*\n * Algolia Search library initialization\n * https://www.algolia.com/\n *\n * @param {string} applicationID - Your applicationID, found in your dashboard\n * @param {string} apiKey - Your API key, found in your dashboard\n * @param {Object} [opts]\n * @param {number} [opts.timeout=2000] - The request timeout set in milliseconds,\n * another request will be issued after this timeout\n * @param {string} [opts.protocol='https:'] - The protocol used to query Algolia Search API.\n *                                        Set to 'http:' to force using http.\n * @param {Object|Array} [opts.hosts={\n *           read: [this.applicationID + '-dsn.algolia.net'].concat([\n *             this.applicationID + '-1.algolianet.com',\n *             this.applicationID + '-2.algolianet.com',\n *             this.applicationID + '-3.algolianet.com']\n *           ]),\n *           write: [this.applicationID + '.algolia.net'].concat([\n *             this.applicationID + '-1.algolianet.com',\n *             this.applicationID + '-2.algolianet.com',\n *             this.applicationID + '-3.algolianet.com']\n *           ]) - The hosts to use for Algolia Search API.\n *           If you provide them, you will less benefit from our HA implementation\n */\nfunction AlgoliaSearchCore(applicationID, apiKey, opts) {\n  var debug = require('debug')('algoliasearch');\n  var clone = require('./clone.js');\n  var isArray = require('isarray');\n  var map = require('./map.js');\n  var usage = 'Usage: algoliasearch(applicationID, apiKey, opts)';\n  if (opts._allowEmptyCredentials !== true && !applicationID) {\n    throw new errors.AlgoliaSearchError('Please provide an application ID. ' + usage);\n  }\n  if (opts._allowEmptyCredentials !== true && !apiKey) {\n    throw new errors.AlgoliaSearchError('Please provide an API key. ' + usage);\n  }\n  this.applicationID = applicationID;\n  this.apiKey = apiKey;\n  this.hosts = {\n    read: [],\n    write: []\n  };\n  opts = opts || {};\n  this._timeouts = opts.timeouts || {\n    connect: 1 * 1000,\n    // 500ms connect is GPRS latency\n    read: 2 * 1000,\n    write: 30 * 1000\n  };\n\n  // backward compat, if opts.timeout is passed, we use it to configure all timeouts like before\n  if (opts.timeout) {\n    this._timeouts.connect = this._timeouts.read = this._timeouts.write = opts.timeout;\n  }\n  var protocol = opts.protocol || 'https:';\n  // while we advocate for colon-at-the-end values: 'http:' for `opts.protocol`\n  // we also accept `http` and `https`. It's a common error.\n  if (!/:$/.test(protocol)) {\n    protocol = protocol + ':';\n  }\n  if (protocol !== 'http:' && protocol !== 'https:') {\n    throw new errors.AlgoliaSearchError('protocol must be `http:` or `https:` (was `' + opts.protocol + '`)');\n  }\n  this._checkAppIdData();\n  if (!opts.hosts) {\n    var defaultHosts = map(this._shuffleResult, function (hostNumber) {\n      return applicationID + '-' + hostNumber + '.algolianet.com';\n    });\n\n    // no hosts given, compute defaults\n    var mainSuffix = (opts.dsn === false ? '' : '-dsn') + '.algolia.net';\n    this.hosts.read = [this.applicationID + mainSuffix].concat(defaultHosts);\n    this.hosts.write = [this.applicationID + '.algolia.net'].concat(defaultHosts);\n  } else if (isArray(opts.hosts)) {\n    // when passing custom hosts, we need to have a different host index if the number\n    // of write/read hosts are different.\n    this.hosts.read = clone(opts.hosts);\n    this.hosts.write = clone(opts.hosts);\n  } else {\n    this.hosts.read = clone(opts.hosts.read);\n    this.hosts.write = clone(opts.hosts.write);\n  }\n\n  // add protocol and lowercase hosts\n  this.hosts.read = map(this.hosts.read, prepareHost(protocol));\n  this.hosts.write = map(this.hosts.write, prepareHost(protocol));\n  this.extraHeaders = {};\n\n  // In some situations you might want to warm the cache\n  this.cache = opts._cache || {};\n  this._ua = opts._ua;\n  this._useCache = opts._useCache === undefined || opts._cache ? true : opts._useCache;\n  this._useRequestCache = this._useCache && opts._useRequestCache;\n  this._useFallback = opts.useFallback === undefined ? true : opts.useFallback;\n  this._setTimeout = opts._setTimeout;\n  debug('init done, %j', this);\n}\n\n/*\n * Get the index object initialized\n *\n * @param indexName the name of index\n * @param callback the result callback with one argument (the Index instance)\n */\nAlgoliaSearchCore.prototype.initIndex = function (indexName) {\n  return new IndexCore(this, indexName);\n};\n\n/**\n* Add an extra field to the HTTP request\n*\n* @param name the header field name\n* @param value the header field value\n*/\nAlgoliaSearchCore.prototype.setExtraHeader = function (name, value) {\n  this.extraHeaders[name.toLowerCase()] = value;\n};\n\n/**\n* Get the value of an extra HTTP header\n*\n* @param name the header field name\n*/\nAlgoliaSearchCore.prototype.getExtraHeader = function (name) {\n  return this.extraHeaders[name.toLowerCase()];\n};\n\n/**\n* Remove an extra field from the HTTP request\n*\n* @param name the header field name\n*/\nAlgoliaSearchCore.prototype.unsetExtraHeader = function (name) {\n  delete this.extraHeaders[name.toLowerCase()];\n};\n\n/**\n* Augment sent x-algolia-agent with more data, each agent part\n* is automatically separated from the others by a semicolon;\n*\n* @param algoliaAgent the agent to add\n*/\nAlgoliaSearchCore.prototype.addAlgoliaAgent = function (algoliaAgent) {\n  var algoliaAgentWithDelimiter = '; ' + algoliaAgent;\n  if (this._ua.indexOf(algoliaAgentWithDelimiter) === -1) {\n    this._ua += algoliaAgentWithDelimiter;\n  }\n};\n\n/*\n * Wrapper that try all hosts to maximize the quality of service\n */\nAlgoliaSearchCore.prototype._jsonRequest = function (initialOpts) {\n  this._checkAppIdData();\n  var requestDebug = require('debug')('algoliasearch:' + initialOpts.url);\n  var body;\n  var cacheID;\n  var additionalUA = initialOpts.additionalUA || '';\n  var cache = initialOpts.cache;\n  var client = this;\n  var tries = 0;\n  var usingFallback = false;\n  var hasFallback = client._useFallback && client._request.fallback && initialOpts.fallback;\n  var headers;\n  if (this.apiKey.length > MAX_API_KEY_LENGTH && initialOpts.body !== undefined && (initialOpts.body.params !== undefined ||\n  // index.search()\n  initialOpts.body.requests !== undefined) // client.search()\n  ) {\n    initialOpts.body.apiKey = this.apiKey;\n    headers = this._computeRequestHeaders({\n      additionalUA: additionalUA,\n      withApiKey: false,\n      headers: initialOpts.headers\n    });\n  } else {\n    headers = this._computeRequestHeaders({\n      additionalUA: additionalUA,\n      headers: initialOpts.headers\n    });\n  }\n  if (initialOpts.body !== undefined) {\n    body = safeJSONStringify(initialOpts.body);\n  }\n  requestDebug('request start');\n  var debugData = [];\n  function doRequest(requester, reqOpts) {\n    client._checkAppIdData();\n    var startTime = new Date();\n    if (client._useCache && !client._useRequestCache) {\n      cacheID = initialOpts.url;\n    }\n\n    // as we sometime use POST requests to pass parameters (like query='aa'),\n    // the cacheID must also include the body to be different between calls\n    if (client._useCache && !client._useRequestCache && body) {\n      cacheID += '_body_' + reqOpts.body;\n    }\n\n    // handle cache existence\n    if (isCacheValidWithCurrentID(!client._useRequestCache, cache, cacheID)) {\n      requestDebug('serving response from cache');\n      var responseText = cache[cacheID];\n\n      // Cache response must match the type of the original one\n      return client._promise.resolve({\n        body: JSON.parse(responseText),\n        responseText: responseText\n      });\n    }\n\n    // if we reached max tries\n    if (tries >= client.hosts[initialOpts.hostType].length) {\n      if (!hasFallback || usingFallback) {\n        requestDebug('could not get any response');\n        // then stop\n        return client._promise.reject(new errors.AlgoliaSearchError('Cannot connect to the AlgoliaSearch API.' + ' Send an email to support@algolia.com to report and resolve the issue.' + ' Application id was: ' + client.applicationID, {\n          debugData: debugData\n        }));\n      }\n      requestDebug('switching to fallback');\n\n      // let's try the fallback starting from here\n      tries = 0;\n\n      // method, url and body are fallback dependent\n      reqOpts.method = initialOpts.fallback.method;\n      reqOpts.url = initialOpts.fallback.url;\n      reqOpts.jsonBody = initialOpts.fallback.body;\n      if (reqOpts.jsonBody) {\n        reqOpts.body = safeJSONStringify(reqOpts.jsonBody);\n      }\n      // re-compute headers, they could be omitting the API KEY\n      headers = client._computeRequestHeaders({\n        additionalUA: additionalUA,\n        headers: initialOpts.headers\n      });\n      reqOpts.timeouts = client._getTimeoutsForRequest(initialOpts.hostType);\n      client._setHostIndexByType(0, initialOpts.hostType);\n      usingFallback = true; // the current request is now using fallback\n      return doRequest(client._request.fallback, reqOpts);\n    }\n    var currentHost = client._getHostByType(initialOpts.hostType);\n    var url = currentHost + reqOpts.url;\n    var options = {\n      body: reqOpts.body,\n      jsonBody: reqOpts.jsonBody,\n      method: reqOpts.method,\n      headers: headers,\n      timeouts: reqOpts.timeouts,\n      debug: requestDebug,\n      forceAuthHeaders: reqOpts.forceAuthHeaders\n    };\n    requestDebug('method: %s, url: %s, headers: %j, timeouts: %d', options.method, url, options.headers, options.timeouts);\n    if (requester === client._request.fallback) {\n      requestDebug('using fallback');\n    }\n\n    // `requester` is any of this._request or this._request.fallback\n    // thus it needs to be called using the client as context\n    return requester.call(client, url, options).then(success, tryFallback);\n    function success(httpResponse) {\n      // compute the status of the response,\n      //\n      // When in browser mode, using XDR or JSONP, we have no statusCode available\n      // So we rely on our API response `status` property.\n      // But `waitTask` can set a `status` property which is not the statusCode (it's the task status)\n      // So we check if there's a `message` along `status` and it means it's an error\n      //\n      // That's the only case where we have a response.status that's not the http statusCode\n      var status = httpResponse && httpResponse.body && httpResponse.body.message && httpResponse.body.status ||\n      // this is important to check the request statusCode AFTER the body eventual\n      // statusCode because some implementations (jQuery XDomainRequest transport) may\n      // send statusCode 200 while we had an error\n      httpResponse.statusCode ||\n      // When in browser mode, using XDR or JSONP\n      // we default to success when no error (no response.status && response.message)\n      // If there was a JSON.parse() error then body is null and it fails\n      httpResponse && httpResponse.body && 200;\n      requestDebug('received response: statusCode: %s, computed statusCode: %d, headers: %j', httpResponse.statusCode, status, httpResponse.headers);\n      var httpResponseOk = Math.floor(status / 100) === 2;\n      var endTime = new Date();\n      debugData.push({\n        currentHost: currentHost,\n        headers: removeCredentials(headers),\n        content: body || null,\n        contentLength: body !== undefined ? body.length : null,\n        method: reqOpts.method,\n        timeouts: reqOpts.timeouts,\n        url: reqOpts.url,\n        startTime: startTime,\n        endTime: endTime,\n        duration: endTime - startTime,\n        statusCode: status\n      });\n      if (httpResponseOk) {\n        if (client._useCache && !client._useRequestCache && cache) {\n          cache[cacheID] = httpResponse.responseText;\n        }\n        return {\n          responseText: httpResponse.responseText,\n          body: httpResponse.body\n        };\n      }\n      var shouldRetry = Math.floor(status / 100) !== 4;\n      if (shouldRetry) {\n        tries += 1;\n        return retryRequest();\n      }\n      requestDebug('unrecoverable error');\n\n      // no success and no retry => fail\n      var unrecoverableError = new errors.AlgoliaSearchError(httpResponse.body && httpResponse.body.message, {\n        debugData: debugData,\n        statusCode: status\n      });\n      return client._promise.reject(unrecoverableError);\n    }\n    function tryFallback(err) {\n      // error cases:\n      //  While not in fallback mode:\n      //    - CORS not supported\n      //    - network error\n      //  While in fallback mode:\n      //    - timeout\n      //    - network error\n      //    - badly formatted JSONP (script loaded, did not call our callback)\n      //  In both cases:\n      //    - uncaught exception occurs (TypeError)\n      requestDebug('error: %s, stack: %s', err.message, err.stack);\n      var endTime = new Date();\n      debugData.push({\n        currentHost: currentHost,\n        headers: removeCredentials(headers),\n        content: body || null,\n        contentLength: body !== undefined ? body.length : null,\n        method: reqOpts.method,\n        timeouts: reqOpts.timeouts,\n        url: reqOpts.url,\n        startTime: startTime,\n        endTime: endTime,\n        duration: endTime - startTime\n      });\n      if (!(err instanceof errors.AlgoliaSearchError)) {\n        err = new errors.Unknown(err && err.message, err);\n      }\n      tries += 1;\n\n      // stop the request implementation when:\n      if (\n      // we did not generate this error,\n      // it comes from a throw in some other piece of code\n      err instanceof errors.Unknown ||\n      // server sent unparsable JSON\n      err instanceof errors.UnparsableJSON ||\n      // max tries and already using fallback or no fallback\n      tries >= client.hosts[initialOpts.hostType].length && (usingFallback || !hasFallback)) {\n        // stop request implementation for this command\n        err.debugData = debugData;\n        return client._promise.reject(err);\n      }\n\n      // When a timeout occurred, retry by raising timeout\n      if (err instanceof errors.RequestTimeout) {\n        return retryRequestWithHigherTimeout();\n      }\n      return retryRequest();\n    }\n    function retryRequest() {\n      requestDebug('retrying request');\n      client._incrementHostIndex(initialOpts.hostType);\n      return doRequest(requester, reqOpts);\n    }\n    function retryRequestWithHigherTimeout() {\n      requestDebug('retrying request with higher timeout');\n      client._incrementHostIndex(initialOpts.hostType);\n      client._incrementTimeoutMultipler();\n      reqOpts.timeouts = client._getTimeoutsForRequest(initialOpts.hostType);\n      return doRequest(requester, reqOpts);\n    }\n  }\n  function isCacheValidWithCurrentID(useRequestCache, currentCache, currentCacheID) {\n    return client._useCache && useRequestCache && currentCache && currentCache[currentCacheID] !== undefined;\n  }\n  function interopCallbackReturn(request, callback) {\n    if (isCacheValidWithCurrentID(client._useRequestCache, cache, cacheID)) {\n      request.catch(function () {\n        // Release the cache on error\n        delete cache[cacheID];\n      });\n    }\n    if (typeof initialOpts.callback === 'function') {\n      // either we have a callback\n      request.then(function okCb(content) {\n        exitPromise(function () {\n          initialOpts.callback(null, callback(content));\n        }, client._setTimeout || setTimeout);\n      }, function nookCb(err) {\n        exitPromise(function () {\n          initialOpts.callback(err);\n        }, client._setTimeout || setTimeout);\n      });\n    } else {\n      // either we are using promises\n      return request.then(callback);\n    }\n  }\n  if (client._useCache && client._useRequestCache) {\n    cacheID = initialOpts.url;\n  }\n\n  // as we sometime use POST requests to pass parameters (like query='aa'),\n  // the cacheID must also include the body to be different between calls\n  if (client._useCache && client._useRequestCache && body) {\n    cacheID += '_body_' + body;\n  }\n  if (isCacheValidWithCurrentID(client._useRequestCache, cache, cacheID)) {\n    requestDebug('serving request from cache');\n    var maybePromiseForCache = cache[cacheID];\n\n    // In case the cache is warmup with value that is not a promise\n    var promiseForCache = typeof maybePromiseForCache.then !== 'function' ? client._promise.resolve({\n      responseText: maybePromiseForCache\n    }) : maybePromiseForCache;\n    return interopCallbackReturn(promiseForCache, function (content) {\n      // In case of the cache request, return the original value\n      return JSON.parse(content.responseText);\n    });\n  }\n  var request = doRequest(client._request, {\n    url: initialOpts.url,\n    method: initialOpts.method,\n    body: body,\n    jsonBody: initialOpts.body,\n    timeouts: client._getTimeoutsForRequest(initialOpts.hostType),\n    forceAuthHeaders: initialOpts.forceAuthHeaders\n  });\n  if (client._useCache && client._useRequestCache && cache) {\n    cache[cacheID] = request;\n  }\n  return interopCallbackReturn(request, function (content) {\n    // In case of the first request, return the JSON value\n    return content.body;\n  });\n};\n\n/*\n* Transform search param object in query string\n* @param {object} args arguments to add to the current query string\n* @param {string} params current query string\n* @return {string} the final query string\n*/\nAlgoliaSearchCore.prototype._getSearchParams = function (args, params) {\n  if (args === undefined || args === null) {\n    return params;\n  }\n  for (var key in args) {\n    if (key !== null && args[key] !== undefined && args.hasOwnProperty(key)) {\n      params += params === '' ? '' : '&';\n      params += key + '=' + encodeURIComponent(Object.prototype.toString.call(args[key]) === '[object Array]' ? safeJSONStringify(args[key]) : args[key]);\n    }\n  }\n  return params;\n};\n\n/**\n * Compute the headers for a request\n *\n * @param [string] options.additionalUA semi-colon separated string with other user agents to add\n * @param [boolean=true] options.withApiKey Send the api key as a header\n * @param [Object] options.headers Extra headers to send\n */\nAlgoliaSearchCore.prototype._computeRequestHeaders = function (options) {\n  var forEach = require('foreach');\n  var ua = options.additionalUA ? this._ua + '; ' + options.additionalUA : this._ua;\n  var requestHeaders = {\n    'x-algolia-agent': ua,\n    'x-algolia-application-id': this.applicationID\n  };\n\n  // browser will inline headers in the url, node.js will use http headers\n  // but in some situations, the API KEY will be too long (big secured API keys)\n  // so if the request is a POST and the KEY is very long, we will be asked to not put\n  // it into headers but in the JSON body\n  if (options.withApiKey !== false) {\n    requestHeaders['x-algolia-api-key'] = this.apiKey;\n  }\n  if (this.userToken) {\n    requestHeaders['x-algolia-usertoken'] = this.userToken;\n  }\n  if (this.securityTags) {\n    requestHeaders['x-algolia-tagfilters'] = this.securityTags;\n  }\n  forEach(this.extraHeaders, function addToRequestHeaders(value, key) {\n    requestHeaders[key] = value;\n  });\n  if (options.headers) {\n    forEach(options.headers, function addToRequestHeaders(value, key) {\n      requestHeaders[key] = value;\n    });\n  }\n  return requestHeaders;\n};\n\n/**\n * Search through multiple indices at the same time\n * @param  {Object[]}   queries  An array of queries you want to run.\n * @param {string} queries[].indexName The index name you want to target\n * @param {string} [queries[].query] The query to issue on this index. Can also be passed into `params`\n * @param {Object} queries[].params Any search param like hitsPerPage, ..\n * @param  {Function} callback Callback to be called\n * @return {Promise|undefined} Returns a promise if no callback given\n */\nAlgoliaSearchCore.prototype.search = function (queries, opts, callback) {\n  var isArray = require('isarray');\n  var map = require('./map.js');\n  var usage = 'Usage: client.search(arrayOfQueries[, callback])';\n  if (!isArray(queries)) {\n    throw new Error(usage);\n  }\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  } else if (opts === undefined) {\n    opts = {};\n  }\n  var client = this;\n  var postObj = {\n    requests: map(queries, function prepareRequest(query) {\n      var params = '';\n\n      // allow query.query\n      // so we are mimicing the index.search(query, params) method\n      // {indexName:, query:, params:}\n      if (query.query !== undefined) {\n        params += 'query=' + encodeURIComponent(query.query);\n      }\n      return {\n        indexName: query.indexName,\n        params: client._getSearchParams(query.params, params)\n      };\n    })\n  };\n  var JSONPParams = map(postObj.requests, function prepareJSONPParams(request, requestId) {\n    return requestId + '=' + encodeURIComponent('/1/indexes/' + encodeURIComponent(request.indexName) + '?' + request.params);\n  }).join('&');\n  var url = '/1/indexes/*/queries';\n  if (opts.strategy !== undefined) {\n    postObj.strategy = opts.strategy;\n  }\n  return this._jsonRequest({\n    cache: this.cache,\n    method: 'POST',\n    url: url,\n    body: postObj,\n    hostType: 'read',\n    fallback: {\n      method: 'GET',\n      url: '/1/indexes/*',\n      body: {\n        params: JSONPParams\n      }\n    },\n    callback: callback\n  });\n};\n\n/**\n* Search for facet values\n* https://www.algolia.com/doc/rest-api/search#search-for-facet-values\n* This is the top-level API for SFFV.\n*\n* @param {object[]} queries An array of queries to run.\n* @param {string} queries[].indexName Index name, name of the index to search.\n* @param {object} queries[].params Query parameters.\n* @param {string} queries[].params.facetName Facet name, name of the attribute to search for values in.\n* Must be declared as a facet\n* @param {string} queries[].params.facetQuery Query for the facet search\n* @param {string} [queries[].params.*] Any search parameter of Algolia,\n* see https://www.algolia.com/doc/api-client/javascript/search#search-parameters\n* Pagination is not supported. The page and hitsPerPage parameters will be ignored.\n*/\nAlgoliaSearchCore.prototype.searchForFacetValues = function (queries) {\n  var isArray = require('isarray');\n  var map = require('./map.js');\n  var usage = 'Usage: client.searchForFacetValues([{indexName, params: {facetName, facetQuery, ...params}}, ...queries])'; // eslint-disable-line max-len\n\n  if (!isArray(queries)) {\n    throw new Error(usage);\n  }\n  var client = this;\n  return client._promise.all(map(queries, function performQuery(query) {\n    if (!query || query.indexName === undefined || query.params.facetName === undefined || query.params.facetQuery === undefined) {\n      throw new Error(usage);\n    }\n    var clone = require('./clone.js');\n    var omit = require('./omit.js');\n    var indexName = query.indexName;\n    var params = query.params;\n    var facetName = params.facetName;\n    var filteredParams = omit(clone(params), function (keyName) {\n      return keyName === 'facetName';\n    });\n    var searchParameters = client._getSearchParams(filteredParams, '');\n    return client._jsonRequest({\n      cache: client.cache,\n      method: 'POST',\n      url: '/1/indexes/' + encodeURIComponent(indexName) + '/facets/' + encodeURIComponent(facetName) + '/query',\n      hostType: 'read',\n      body: {\n        params: searchParameters\n      }\n    });\n  }));\n};\n\n/**\n * Set the extra security tagFilters header\n * @param {string|array} tags The list of tags defining the current security filters\n */\nAlgoliaSearchCore.prototype.setSecurityTags = function (tags) {\n  if (Object.prototype.toString.call(tags) === '[object Array]') {\n    var strTags = [];\n    for (var i = 0; i < tags.length; ++i) {\n      if (Object.prototype.toString.call(tags[i]) === '[object Array]') {\n        var oredTags = [];\n        for (var j = 0; j < tags[i].length; ++j) {\n          oredTags.push(tags[i][j]);\n        }\n        strTags.push('(' + oredTags.join(',') + ')');\n      } else {\n        strTags.push(tags[i]);\n      }\n    }\n    tags = strTags.join(',');\n  }\n  this.securityTags = tags;\n};\n\n/**\n * Set the extra user token header\n * @param {string} userToken The token identifying a uniq user (used to apply rate limits)\n */\nAlgoliaSearchCore.prototype.setUserToken = function (userToken) {\n  this.userToken = userToken;\n};\n\n/**\n * Clear all queries in client's cache\n * @return undefined\n */\nAlgoliaSearchCore.prototype.clearCache = function () {\n  this.cache = {};\n};\n\n/**\n* Set the number of milliseconds a request can take before automatically being terminated.\n* @deprecated\n* @param {Number} milliseconds\n*/\nAlgoliaSearchCore.prototype.setRequestTimeout = function (milliseconds) {\n  if (milliseconds) {\n    this._timeouts.connect = this._timeouts.read = this._timeouts.write = milliseconds;\n  }\n};\n\n/**\n* Set the three different (connect, read, write) timeouts to be used when requesting\n* @param {Object} timeouts\n*/\nAlgoliaSearchCore.prototype.setTimeouts = function (timeouts) {\n  this._timeouts = timeouts;\n};\n\n/**\n* Get the three different (connect, read, write) timeouts to be used when requesting\n* @param {Object} timeouts\n*/\nAlgoliaSearchCore.prototype.getTimeouts = function () {\n  return this._timeouts;\n};\nAlgoliaSearchCore.prototype._getAppIdData = function () {\n  var data = store.get(this.applicationID);\n  if (data !== null) this._cacheAppIdData(data);\n  return data;\n};\nAlgoliaSearchCore.prototype._setAppIdData = function (data) {\n  data.lastChange = new Date().getTime();\n  this._cacheAppIdData(data);\n  return store.set(this.applicationID, data);\n};\nAlgoliaSearchCore.prototype._checkAppIdData = function () {\n  var data = this._getAppIdData();\n  var now = new Date().getTime();\n  if (data === null || now - data.lastChange > RESET_APP_DATA_TIMER) {\n    return this._resetInitialAppIdData(data);\n  }\n  return data;\n};\nAlgoliaSearchCore.prototype._resetInitialAppIdData = function (data) {\n  var newData = data || {};\n  newData.hostIndexes = {\n    read: 0,\n    write: 0\n  };\n  newData.timeoutMultiplier = 1;\n  newData.shuffleResult = newData.shuffleResult || shuffle([1, 2, 3]);\n  return this._setAppIdData(newData);\n};\nAlgoliaSearchCore.prototype._cacheAppIdData = function (data) {\n  this._hostIndexes = data.hostIndexes;\n  this._timeoutMultiplier = data.timeoutMultiplier;\n  this._shuffleResult = data.shuffleResult;\n};\nAlgoliaSearchCore.prototype._partialAppIdDataUpdate = function (newData) {\n  var foreach = require('foreach');\n  var currentData = this._getAppIdData();\n  foreach(newData, function (value, key) {\n    currentData[key] = value;\n  });\n  return this._setAppIdData(currentData);\n};\nAlgoliaSearchCore.prototype._getHostByType = function (hostType) {\n  return this.hosts[hostType][this._getHostIndexByType(hostType)];\n};\nAlgoliaSearchCore.prototype._getTimeoutMultiplier = function () {\n  return this._timeoutMultiplier;\n};\nAlgoliaSearchCore.prototype._getHostIndexByType = function (hostType) {\n  return this._hostIndexes[hostType];\n};\nAlgoliaSearchCore.prototype._setHostIndexByType = function (hostIndex, hostType) {\n  var clone = require('./clone');\n  var newHostIndexes = clone(this._hostIndexes);\n  newHostIndexes[hostType] = hostIndex;\n  this._partialAppIdDataUpdate({\n    hostIndexes: newHostIndexes\n  });\n  return hostIndex;\n};\nAlgoliaSearchCore.prototype._incrementHostIndex = function (hostType) {\n  return this._setHostIndexByType((this._getHostIndexByType(hostType) + 1) % this.hosts[hostType].length, hostType);\n};\nAlgoliaSearchCore.prototype._incrementTimeoutMultipler = function () {\n  var timeoutMultiplier = Math.max(this._timeoutMultiplier + 1, 4);\n  return this._partialAppIdDataUpdate({\n    timeoutMultiplier: timeoutMultiplier\n  });\n};\nAlgoliaSearchCore.prototype._getTimeoutsForRequest = function (hostType) {\n  return {\n    connect: this._timeouts.connect * this._timeoutMultiplier,\n    complete: this._timeouts[hostType] * this._timeoutMultiplier\n  };\n};\nfunction prepareHost(protocol) {\n  return function prepare(host) {\n    return protocol + '//' + host.toLowerCase();\n  };\n}\n\n// Prototype.js < 1.7, a widely used library, defines a weird\n// Array.prototype.toJSON function that will fail to stringify our content\n// appropriately\n// refs:\n//   - https://groups.google.com/forum/#!topic/prototype-core/E-SAVvV_V9Q\n//   - https://github.com/sstephenson/prototype/commit/038a2985a70593c1a86c230fadbdfe2e4898a48c\n//   - http://stackoverflow.com/a/3148441/147079\nfunction safeJSONStringify(obj) {\n  /* eslint no-extend-native:0 */\n\n  if (Array.prototype.toJSON === undefined) {\n    return JSON.stringify(obj);\n  }\n  var toJSON = Array.prototype.toJSON;\n  delete Array.prototype.toJSON;\n  var out = JSON.stringify(obj);\n  Array.prototype.toJSON = toJSON;\n  return out;\n}\nfunction shuffle(array) {\n  var currentIndex = array.length;\n  var temporaryValue;\n  var randomIndex;\n\n  // While there remain elements to shuffle...\n  while (currentIndex !== 0) {\n    // Pick a remaining element...\n    randomIndex = Math.floor(Math.random() * currentIndex);\n    currentIndex -= 1;\n\n    // And swap it with the current element.\n    temporaryValue = array[currentIndex];\n    array[currentIndex] = array[randomIndex];\n    array[randomIndex] = temporaryValue;\n  }\n  return array;\n}\nfunction removeCredentials(headers) {\n  var newHeaders = {};\n  for (var headerName in headers) {\n    if (Object.prototype.hasOwnProperty.call(headers, headerName)) {\n      var value;\n      if (headerName === 'x-algolia-api-key' || headerName === 'x-algolia-application-id') {\n        value = '**hidden for security purposes**';\n      } else {\n        value = headers[headerName];\n      }\n      newHeaders[headerName] = value;\n    }\n  }\n  return newHeaders;\n}","map":{"version":3,"names":["module","exports","AlgoliaSearchCore","errors","require","exitPromise","IndexCore","store","MAX_API_KEY_LENGTH","RESET_APP_DATA_TIMER","process","env","parseInt","applicationID","apiKey","opts","debug","clone","isArray","map","usage","_allowEmptyCredentials","AlgoliaSearchError","hosts","read","write","_timeouts","timeouts","connect","timeout","protocol","test","_checkAppIdData","defaultHosts","_shuffleResult","hostNumber","mainSuffix","dsn","concat","prepareHost","extraHeaders","cache","_cache","_ua","_useCache","undefined","_useRequestCache","_useFallback","useFallback","_setTimeout","prototype","initIndex","indexName","setExtraHeader","name","value","toLowerCase","getExtraHeader","unsetExtraHeader","addAlgoliaAgent","algoliaAgent","algoliaAgentWithDelimiter","indexOf","_jsonRequest","initialOpts","requestDebug","url","body","cacheID","additionalUA","client","tries","usingFallback","hasFallback","_request","fallback","headers","length","params","requests","_computeRequestHeaders","withApiKey","safeJSONStringify","debugData","doRequest","requester","reqOpts","startTime","Date","isCacheValidWithCurrentID","responseText","_promise","resolve","JSON","parse","hostType","reject","method","jsonBody","_getTimeoutsForRequest","_setHostIndexByType","currentHost","_getHostByType","options","forceAuthHeaders","call","then","success","tryFallback","httpResponse","status","message","statusCode","httpResponseOk","Math","floor","endTime","push","removeCredentials","content","contentLength","duration","shouldRetry","retryRequest","unrecoverableError","err","stack","Unknown","UnparsableJSON","RequestTimeout","retryRequestWithHigherTimeout","_incrementHostIndex","_incrementTimeoutMultipler","useRequestCache","currentCache","currentCacheID","interopCallbackReturn","request","callback","catch","okCb","setTimeout","nookCb","maybePromiseForCache","promiseForCache","_getSearchParams","args","key","hasOwnProperty","encodeURIComponent","Object","toString","forEach","ua","requestHeaders","userToken","securityTags","addToRequestHeaders","search","queries","Error","postObj","prepareRequest","query","JSONPParams","prepareJSONPParams","requestId","join","strategy","searchForFacetValues","all","performQuery","facetName","facetQuery","omit","filteredParams","keyName","searchParameters","setSecurityTags","tags","strTags","i","oredTags","j","setUserToken","clearCache","setRequestTimeout","milliseconds","setTimeouts","getTimeouts","_getAppIdData","data","get","_cacheAppIdData","_setAppIdData","lastChange","getTime","set","now","_resetInitialAppIdData","newData","hostIndexes","timeoutMultiplier","shuffleResult","shuffle","_hostIndexes","_timeoutMultiplier","_partialAppIdDataUpdate","foreach","currentData","_getHostIndexByType","_getTimeoutMultiplier","hostIndex","newHostIndexes","max","complete","prepare","host","obj","Array","toJSON","stringify","out","array","currentIndex","temporaryValue","randomIndex","random","newHeaders","headerName"],"sources":["/Users/amandawinkler/Desktop/algolia-instantsearch-react-geo/node_modules/algoliasearch/src/AlgoliaSearchCore.js"],"sourcesContent":["module.exports = AlgoliaSearchCore;\n\nvar errors = require('./errors');\nvar exitPromise = require('./exitPromise.js');\nvar IndexCore = require('./IndexCore.js');\nvar store = require('./store.js');\n\n// We will always put the API KEY in the JSON body in case of too long API KEY,\n// to avoid query string being too long and failing in various conditions (our server limit, browser limit,\n// proxies limit)\nvar MAX_API_KEY_LENGTH = 500;\nvar RESET_APP_DATA_TIMER =\n  process.env.RESET_APP_DATA_TIMER && parseInt(process.env.RESET_APP_DATA_TIMER, 10) ||\n  60 * 2 * 1000; // after 2 minutes reset to first host\n\n/*\n * Algolia Search library initialization\n * https://www.algolia.com/\n *\n * @param {string} applicationID - Your applicationID, found in your dashboard\n * @param {string} apiKey - Your API key, found in your dashboard\n * @param {Object} [opts]\n * @param {number} [opts.timeout=2000] - The request timeout set in milliseconds,\n * another request will be issued after this timeout\n * @param {string} [opts.protocol='https:'] - The protocol used to query Algolia Search API.\n *                                        Set to 'http:' to force using http.\n * @param {Object|Array} [opts.hosts={\n *           read: [this.applicationID + '-dsn.algolia.net'].concat([\n *             this.applicationID + '-1.algolianet.com',\n *             this.applicationID + '-2.algolianet.com',\n *             this.applicationID + '-3.algolianet.com']\n *           ]),\n *           write: [this.applicationID + '.algolia.net'].concat([\n *             this.applicationID + '-1.algolianet.com',\n *             this.applicationID + '-2.algolianet.com',\n *             this.applicationID + '-3.algolianet.com']\n *           ]) - The hosts to use for Algolia Search API.\n *           If you provide them, you will less benefit from our HA implementation\n */\nfunction AlgoliaSearchCore(applicationID, apiKey, opts) {\n  var debug = require('debug')('algoliasearch');\n\n  var clone = require('./clone.js');\n  var isArray = require('isarray');\n  var map = require('./map.js');\n\n  var usage = 'Usage: algoliasearch(applicationID, apiKey, opts)';\n\n  if (opts._allowEmptyCredentials !== true && !applicationID) {\n    throw new errors.AlgoliaSearchError('Please provide an application ID. ' + usage);\n  }\n\n  if (opts._allowEmptyCredentials !== true && !apiKey) {\n    throw new errors.AlgoliaSearchError('Please provide an API key. ' + usage);\n  }\n\n  this.applicationID = applicationID;\n  this.apiKey = apiKey;\n\n  this.hosts = {\n    read: [],\n    write: []\n  };\n\n  opts = opts || {};\n\n  this._timeouts = opts.timeouts || {\n    connect: 1 * 1000, // 500ms connect is GPRS latency\n    read: 2 * 1000,\n    write: 30 * 1000\n  };\n\n  // backward compat, if opts.timeout is passed, we use it to configure all timeouts like before\n  if (opts.timeout) {\n    this._timeouts.connect = this._timeouts.read = this._timeouts.write = opts.timeout;\n  }\n\n  var protocol = opts.protocol || 'https:';\n  // while we advocate for colon-at-the-end values: 'http:' for `opts.protocol`\n  // we also accept `http` and `https`. It's a common error.\n  if (!/:$/.test(protocol)) {\n    protocol = protocol + ':';\n  }\n\n  if (protocol !== 'http:' && protocol !== 'https:') {\n    throw new errors.AlgoliaSearchError('protocol must be `http:` or `https:` (was `' + opts.protocol + '`)');\n  }\n\n  this._checkAppIdData();\n\n  if (!opts.hosts) {\n    var defaultHosts = map(this._shuffleResult, function(hostNumber) {\n      return applicationID + '-' + hostNumber + '.algolianet.com';\n    });\n\n    // no hosts given, compute defaults\n    var mainSuffix = (opts.dsn === false ? '' : '-dsn') + '.algolia.net';\n    this.hosts.read = [this.applicationID + mainSuffix].concat(defaultHosts);\n    this.hosts.write = [this.applicationID + '.algolia.net'].concat(defaultHosts);\n  } else if (isArray(opts.hosts)) {\n    // when passing custom hosts, we need to have a different host index if the number\n    // of write/read hosts are different.\n    this.hosts.read = clone(opts.hosts);\n    this.hosts.write = clone(opts.hosts);\n  } else {\n    this.hosts.read = clone(opts.hosts.read);\n    this.hosts.write = clone(opts.hosts.write);\n  }\n\n  // add protocol and lowercase hosts\n  this.hosts.read = map(this.hosts.read, prepareHost(protocol));\n  this.hosts.write = map(this.hosts.write, prepareHost(protocol));\n\n  this.extraHeaders = {};\n\n  // In some situations you might want to warm the cache\n  this.cache = opts._cache || {};\n\n  this._ua = opts._ua;\n  this._useCache = opts._useCache === undefined || opts._cache ? true : opts._useCache;\n  this._useRequestCache = this._useCache && opts._useRequestCache;\n  this._useFallback = opts.useFallback === undefined ? true : opts.useFallback;\n\n  this._setTimeout = opts._setTimeout;\n\n  debug('init done, %j', this);\n}\n\n/*\n * Get the index object initialized\n *\n * @param indexName the name of index\n * @param callback the result callback with one argument (the Index instance)\n */\nAlgoliaSearchCore.prototype.initIndex = function(indexName) {\n  return new IndexCore(this, indexName);\n};\n\n/**\n* Add an extra field to the HTTP request\n*\n* @param name the header field name\n* @param value the header field value\n*/\nAlgoliaSearchCore.prototype.setExtraHeader = function(name, value) {\n  this.extraHeaders[name.toLowerCase()] = value;\n};\n\n/**\n* Get the value of an extra HTTP header\n*\n* @param name the header field name\n*/\nAlgoliaSearchCore.prototype.getExtraHeader = function(name) {\n  return this.extraHeaders[name.toLowerCase()];\n};\n\n/**\n* Remove an extra field from the HTTP request\n*\n* @param name the header field name\n*/\nAlgoliaSearchCore.prototype.unsetExtraHeader = function(name) {\n  delete this.extraHeaders[name.toLowerCase()];\n};\n\n/**\n* Augment sent x-algolia-agent with more data, each agent part\n* is automatically separated from the others by a semicolon;\n*\n* @param algoliaAgent the agent to add\n*/\nAlgoliaSearchCore.prototype.addAlgoliaAgent = function(algoliaAgent) {\n  var algoliaAgentWithDelimiter = '; ' + algoliaAgent;\n\n  if (this._ua.indexOf(algoliaAgentWithDelimiter) === -1) {\n    this._ua += algoliaAgentWithDelimiter;\n  }\n};\n\n/*\n * Wrapper that try all hosts to maximize the quality of service\n */\nAlgoliaSearchCore.prototype._jsonRequest = function(initialOpts) {\n  this._checkAppIdData();\n\n  var requestDebug = require('debug')('algoliasearch:' + initialOpts.url);\n\n\n  var body;\n  var cacheID;\n  var additionalUA = initialOpts.additionalUA || '';\n  var cache = initialOpts.cache;\n  var client = this;\n  var tries = 0;\n  var usingFallback = false;\n  var hasFallback = client._useFallback && client._request.fallback && initialOpts.fallback;\n  var headers;\n\n  if (\n    this.apiKey.length > MAX_API_KEY_LENGTH &&\n    initialOpts.body !== undefined &&\n    (initialOpts.body.params !== undefined || // index.search()\n    initialOpts.body.requests !== undefined) // client.search()\n  ) {\n    initialOpts.body.apiKey = this.apiKey;\n    headers = this._computeRequestHeaders({\n      additionalUA: additionalUA,\n      withApiKey: false,\n      headers: initialOpts.headers\n    });\n  } else {\n    headers = this._computeRequestHeaders({\n      additionalUA: additionalUA,\n      headers: initialOpts.headers\n    });\n  }\n\n  if (initialOpts.body !== undefined) {\n    body = safeJSONStringify(initialOpts.body);\n  }\n\n  requestDebug('request start');\n  var debugData = [];\n\n\n  function doRequest(requester, reqOpts) {\n    client._checkAppIdData();\n\n    var startTime = new Date();\n\n    if (client._useCache && !client._useRequestCache) {\n      cacheID = initialOpts.url;\n    }\n\n    // as we sometime use POST requests to pass parameters (like query='aa'),\n    // the cacheID must also include the body to be different between calls\n    if (client._useCache && !client._useRequestCache && body) {\n      cacheID += '_body_' + reqOpts.body;\n    }\n\n    // handle cache existence\n    if (isCacheValidWithCurrentID(!client._useRequestCache, cache, cacheID)) {\n      requestDebug('serving response from cache');\n\n      var responseText = cache[cacheID];\n\n      // Cache response must match the type of the original one\n      return client._promise.resolve({\n        body: JSON.parse(responseText),\n        responseText: responseText\n      });\n    }\n\n    // if we reached max tries\n    if (tries >= client.hosts[initialOpts.hostType].length) {\n      if (!hasFallback || usingFallback) {\n        requestDebug('could not get any response');\n        // then stop\n        return client._promise.reject(new errors.AlgoliaSearchError(\n          'Cannot connect to the AlgoliaSearch API.' +\n          ' Send an email to support@algolia.com to report and resolve the issue.' +\n          ' Application id was: ' + client.applicationID, {debugData: debugData}\n        ));\n      }\n\n      requestDebug('switching to fallback');\n\n      // let's try the fallback starting from here\n      tries = 0;\n\n      // method, url and body are fallback dependent\n      reqOpts.method = initialOpts.fallback.method;\n      reqOpts.url = initialOpts.fallback.url;\n      reqOpts.jsonBody = initialOpts.fallback.body;\n      if (reqOpts.jsonBody) {\n        reqOpts.body = safeJSONStringify(reqOpts.jsonBody);\n      }\n      // re-compute headers, they could be omitting the API KEY\n      headers = client._computeRequestHeaders({\n        additionalUA: additionalUA,\n        headers: initialOpts.headers\n      });\n\n      reqOpts.timeouts = client._getTimeoutsForRequest(initialOpts.hostType);\n      client._setHostIndexByType(0, initialOpts.hostType);\n      usingFallback = true; // the current request is now using fallback\n      return doRequest(client._request.fallback, reqOpts);\n    }\n\n    var currentHost = client._getHostByType(initialOpts.hostType);\n\n    var url = currentHost + reqOpts.url;\n    var options = {\n      body: reqOpts.body,\n      jsonBody: reqOpts.jsonBody,\n      method: reqOpts.method,\n      headers: headers,\n      timeouts: reqOpts.timeouts,\n      debug: requestDebug,\n      forceAuthHeaders: reqOpts.forceAuthHeaders\n    };\n\n    requestDebug('method: %s, url: %s, headers: %j, timeouts: %d',\n      options.method, url, options.headers, options.timeouts);\n\n    if (requester === client._request.fallback) {\n      requestDebug('using fallback');\n    }\n\n    // `requester` is any of this._request or this._request.fallback\n    // thus it needs to be called using the client as context\n    return requester.call(client, url, options).then(success, tryFallback);\n\n    function success(httpResponse) {\n      // compute the status of the response,\n      //\n      // When in browser mode, using XDR or JSONP, we have no statusCode available\n      // So we rely on our API response `status` property.\n      // But `waitTask` can set a `status` property which is not the statusCode (it's the task status)\n      // So we check if there's a `message` along `status` and it means it's an error\n      //\n      // That's the only case where we have a response.status that's not the http statusCode\n      var status = httpResponse && httpResponse.body && httpResponse.body.message && httpResponse.body.status ||\n\n        // this is important to check the request statusCode AFTER the body eventual\n        // statusCode because some implementations (jQuery XDomainRequest transport) may\n        // send statusCode 200 while we had an error\n        httpResponse.statusCode ||\n\n        // When in browser mode, using XDR or JSONP\n        // we default to success when no error (no response.status && response.message)\n        // If there was a JSON.parse() error then body is null and it fails\n        httpResponse && httpResponse.body && 200;\n\n      requestDebug('received response: statusCode: %s, computed statusCode: %d, headers: %j',\n        httpResponse.statusCode, status, httpResponse.headers);\n\n      var httpResponseOk = Math.floor(status / 100) === 2;\n\n      var endTime = new Date();\n      debugData.push({\n        currentHost: currentHost,\n        headers: removeCredentials(headers),\n        content: body || null,\n        contentLength: body !== undefined ? body.length : null,\n        method: reqOpts.method,\n        timeouts: reqOpts.timeouts,\n        url: reqOpts.url,\n        startTime: startTime,\n        endTime: endTime,\n        duration: endTime - startTime,\n        statusCode: status\n      });\n\n      if (httpResponseOk) {\n        if (client._useCache && !client._useRequestCache && cache) {\n          cache[cacheID] = httpResponse.responseText;\n        }\n\n        return {\n          responseText: httpResponse.responseText,\n          body: httpResponse.body\n        };\n      }\n\n      var shouldRetry = Math.floor(status / 100) !== 4;\n\n      if (shouldRetry) {\n        tries += 1;\n        return retryRequest();\n      }\n\n      requestDebug('unrecoverable error');\n\n      // no success and no retry => fail\n      var unrecoverableError = new errors.AlgoliaSearchError(\n        httpResponse.body && httpResponse.body.message, {debugData: debugData, statusCode: status}\n      );\n\n      return client._promise.reject(unrecoverableError);\n    }\n\n    function tryFallback(err) {\n      // error cases:\n      //  While not in fallback mode:\n      //    - CORS not supported\n      //    - network error\n      //  While in fallback mode:\n      //    - timeout\n      //    - network error\n      //    - badly formatted JSONP (script loaded, did not call our callback)\n      //  In both cases:\n      //    - uncaught exception occurs (TypeError)\n      requestDebug('error: %s, stack: %s', err.message, err.stack);\n\n      var endTime = new Date();\n      debugData.push({\n        currentHost: currentHost,\n        headers: removeCredentials(headers),\n        content: body || null,\n        contentLength: body !== undefined ? body.length : null,\n        method: reqOpts.method,\n        timeouts: reqOpts.timeouts,\n        url: reqOpts.url,\n        startTime: startTime,\n        endTime: endTime,\n        duration: endTime - startTime\n      });\n\n      if (!(err instanceof errors.AlgoliaSearchError)) {\n        err = new errors.Unknown(err && err.message, err);\n      }\n\n      tries += 1;\n\n      // stop the request implementation when:\n      if (\n        // we did not generate this error,\n        // it comes from a throw in some other piece of code\n        err instanceof errors.Unknown ||\n\n        // server sent unparsable JSON\n        err instanceof errors.UnparsableJSON ||\n\n        // max tries and already using fallback or no fallback\n        tries >= client.hosts[initialOpts.hostType].length &&\n        (usingFallback || !hasFallback)) {\n        // stop request implementation for this command\n        err.debugData = debugData;\n        return client._promise.reject(err);\n      }\n\n      // When a timeout occurred, retry by raising timeout\n      if (err instanceof errors.RequestTimeout) {\n        return retryRequestWithHigherTimeout();\n      }\n\n      return retryRequest();\n    }\n\n    function retryRequest() {\n      requestDebug('retrying request');\n      client._incrementHostIndex(initialOpts.hostType);\n      return doRequest(requester, reqOpts);\n    }\n\n    function retryRequestWithHigherTimeout() {\n      requestDebug('retrying request with higher timeout');\n      client._incrementHostIndex(initialOpts.hostType);\n      client._incrementTimeoutMultipler();\n      reqOpts.timeouts = client._getTimeoutsForRequest(initialOpts.hostType);\n      return doRequest(requester, reqOpts);\n    }\n  }\n\n  function isCacheValidWithCurrentID(\n    useRequestCache,\n    currentCache,\n    currentCacheID\n  ) {\n    return (\n      client._useCache &&\n      useRequestCache &&\n      currentCache &&\n      currentCache[currentCacheID] !== undefined\n    );\n  }\n\n\n  function interopCallbackReturn(request, callback) {\n    if (isCacheValidWithCurrentID(client._useRequestCache, cache, cacheID)) {\n      request.catch(function() {\n        // Release the cache on error\n        delete cache[cacheID];\n      });\n    }\n\n    if (typeof initialOpts.callback === 'function') {\n      // either we have a callback\n      request.then(function okCb(content) {\n        exitPromise(function() {\n          initialOpts.callback(null, callback(content));\n        }, client._setTimeout || setTimeout);\n      }, function nookCb(err) {\n        exitPromise(function() {\n          initialOpts.callback(err);\n        }, client._setTimeout || setTimeout);\n      });\n    } else {\n      // either we are using promises\n      return request.then(callback);\n    }\n  }\n\n  if (client._useCache && client._useRequestCache) {\n    cacheID = initialOpts.url;\n  }\n\n  // as we sometime use POST requests to pass parameters (like query='aa'),\n  // the cacheID must also include the body to be different between calls\n  if (client._useCache && client._useRequestCache && body) {\n    cacheID += '_body_' + body;\n  }\n\n  if (isCacheValidWithCurrentID(client._useRequestCache, cache, cacheID)) {\n    requestDebug('serving request from cache');\n\n    var maybePromiseForCache = cache[cacheID];\n\n    // In case the cache is warmup with value that is not a promise\n    var promiseForCache = typeof maybePromiseForCache.then !== 'function'\n      ? client._promise.resolve({responseText: maybePromiseForCache})\n      : maybePromiseForCache;\n\n    return interopCallbackReturn(promiseForCache, function(content) {\n      // In case of the cache request, return the original value\n      return JSON.parse(content.responseText);\n    });\n  }\n\n  var request = doRequest(\n    client._request, {\n      url: initialOpts.url,\n      method: initialOpts.method,\n      body: body,\n      jsonBody: initialOpts.body,\n      timeouts: client._getTimeoutsForRequest(initialOpts.hostType),\n      forceAuthHeaders: initialOpts.forceAuthHeaders\n    }\n  );\n\n  if (client._useCache && client._useRequestCache && cache) {\n    cache[cacheID] = request;\n  }\n\n  return interopCallbackReturn(request, function(content) {\n    // In case of the first request, return the JSON value\n    return content.body;\n  });\n};\n\n/*\n* Transform search param object in query string\n* @param {object} args arguments to add to the current query string\n* @param {string} params current query string\n* @return {string} the final query string\n*/\nAlgoliaSearchCore.prototype._getSearchParams = function(args, params) {\n  if (args === undefined || args === null) {\n    return params;\n  }\n  for (var key in args) {\n    if (key !== null && args[key] !== undefined && args.hasOwnProperty(key)) {\n      params += params === '' ? '' : '&';\n      params += key + '=' + encodeURIComponent(Object.prototype.toString.call(args[key]) === '[object Array]' ? safeJSONStringify(args[key]) : args[key]);\n    }\n  }\n  return params;\n};\n\n/**\n * Compute the headers for a request\n *\n * @param [string] options.additionalUA semi-colon separated string with other user agents to add\n * @param [boolean=true] options.withApiKey Send the api key as a header\n * @param [Object] options.headers Extra headers to send\n */\nAlgoliaSearchCore.prototype._computeRequestHeaders = function(options) {\n  var forEach = require('foreach');\n\n  var ua = options.additionalUA ?\n    this._ua + '; ' + options.additionalUA :\n    this._ua;\n\n  var requestHeaders = {\n    'x-algolia-agent': ua,\n    'x-algolia-application-id': this.applicationID\n  };\n\n  // browser will inline headers in the url, node.js will use http headers\n  // but in some situations, the API KEY will be too long (big secured API keys)\n  // so if the request is a POST and the KEY is very long, we will be asked to not put\n  // it into headers but in the JSON body\n  if (options.withApiKey !== false) {\n    requestHeaders['x-algolia-api-key'] = this.apiKey;\n  }\n\n  if (this.userToken) {\n    requestHeaders['x-algolia-usertoken'] = this.userToken;\n  }\n\n  if (this.securityTags) {\n    requestHeaders['x-algolia-tagfilters'] = this.securityTags;\n  }\n\n  forEach(this.extraHeaders, function addToRequestHeaders(value, key) {\n    requestHeaders[key] = value;\n  });\n\n  if (options.headers) {\n    forEach(options.headers, function addToRequestHeaders(value, key) {\n      requestHeaders[key] = value;\n    });\n  }\n\n  return requestHeaders;\n};\n\n/**\n * Search through multiple indices at the same time\n * @param  {Object[]}   queries  An array of queries you want to run.\n * @param {string} queries[].indexName The index name you want to target\n * @param {string} [queries[].query] The query to issue on this index. Can also be passed into `params`\n * @param {Object} queries[].params Any search param like hitsPerPage, ..\n * @param  {Function} callback Callback to be called\n * @return {Promise|undefined} Returns a promise if no callback given\n */\nAlgoliaSearchCore.prototype.search = function(queries, opts, callback) {\n  var isArray = require('isarray');\n  var map = require('./map.js');\n\n  var usage = 'Usage: client.search(arrayOfQueries[, callback])';\n\n  if (!isArray(queries)) {\n    throw new Error(usage);\n  }\n\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  } else if (opts === undefined) {\n    opts = {};\n  }\n\n  var client = this;\n\n  var postObj = {\n    requests: map(queries, function prepareRequest(query) {\n      var params = '';\n\n      // allow query.query\n      // so we are mimicing the index.search(query, params) method\n      // {indexName:, query:, params:}\n      if (query.query !== undefined) {\n        params += 'query=' + encodeURIComponent(query.query);\n      }\n\n      return {\n        indexName: query.indexName,\n        params: client._getSearchParams(query.params, params)\n      };\n    })\n  };\n\n  var JSONPParams = map(postObj.requests, function prepareJSONPParams(request, requestId) {\n    return requestId + '=' +\n      encodeURIComponent(\n        '/1/indexes/' + encodeURIComponent(request.indexName) + '?' +\n        request.params\n      );\n  }).join('&');\n\n  var url = '/1/indexes/*/queries';\n\n  if (opts.strategy !== undefined) {\n    postObj.strategy = opts.strategy;\n  }\n\n  return this._jsonRequest({\n    cache: this.cache,\n    method: 'POST',\n    url: url,\n    body: postObj,\n    hostType: 'read',\n    fallback: {\n      method: 'GET',\n      url: '/1/indexes/*',\n      body: {\n        params: JSONPParams\n      }\n    },\n    callback: callback\n  });\n};\n\n/**\n* Search for facet values\n* https://www.algolia.com/doc/rest-api/search#search-for-facet-values\n* This is the top-level API for SFFV.\n*\n* @param {object[]} queries An array of queries to run.\n* @param {string} queries[].indexName Index name, name of the index to search.\n* @param {object} queries[].params Query parameters.\n* @param {string} queries[].params.facetName Facet name, name of the attribute to search for values in.\n* Must be declared as a facet\n* @param {string} queries[].params.facetQuery Query for the facet search\n* @param {string} [queries[].params.*] Any search parameter of Algolia,\n* see https://www.algolia.com/doc/api-client/javascript/search#search-parameters\n* Pagination is not supported. The page and hitsPerPage parameters will be ignored.\n*/\nAlgoliaSearchCore.prototype.searchForFacetValues = function(queries) {\n  var isArray = require('isarray');\n  var map = require('./map.js');\n\n  var usage = 'Usage: client.searchForFacetValues([{indexName, params: {facetName, facetQuery, ...params}}, ...queries])'; // eslint-disable-line max-len\n\n  if (!isArray(queries)) {\n    throw new Error(usage);\n  }\n\n  var client = this;\n\n  return client._promise.all(map(queries, function performQuery(query) {\n    if (\n      !query ||\n      query.indexName === undefined ||\n      query.params.facetName === undefined ||\n      query.params.facetQuery === undefined\n    ) {\n      throw new Error(usage);\n    }\n\n    var clone = require('./clone.js');\n    var omit = require('./omit.js');\n\n    var indexName = query.indexName;\n    var params = query.params;\n\n    var facetName = params.facetName;\n    var filteredParams = omit(clone(params), function(keyName) {\n      return keyName === 'facetName';\n    });\n    var searchParameters = client._getSearchParams(filteredParams, '');\n\n    return client._jsonRequest({\n      cache: client.cache,\n      method: 'POST',\n      url:\n        '/1/indexes/' +\n        encodeURIComponent(indexName) +\n        '/facets/' +\n        encodeURIComponent(facetName) +\n        '/query',\n      hostType: 'read',\n      body: {params: searchParameters}\n    });\n  }));\n};\n\n/**\n * Set the extra security tagFilters header\n * @param {string|array} tags The list of tags defining the current security filters\n */\nAlgoliaSearchCore.prototype.setSecurityTags = function(tags) {\n  if (Object.prototype.toString.call(tags) === '[object Array]') {\n    var strTags = [];\n    for (var i = 0; i < tags.length; ++i) {\n      if (Object.prototype.toString.call(tags[i]) === '[object Array]') {\n        var oredTags = [];\n        for (var j = 0; j < tags[i].length; ++j) {\n          oredTags.push(tags[i][j]);\n        }\n        strTags.push('(' + oredTags.join(',') + ')');\n      } else {\n        strTags.push(tags[i]);\n      }\n    }\n    tags = strTags.join(',');\n  }\n\n  this.securityTags = tags;\n};\n\n/**\n * Set the extra user token header\n * @param {string} userToken The token identifying a uniq user (used to apply rate limits)\n */\nAlgoliaSearchCore.prototype.setUserToken = function(userToken) {\n  this.userToken = userToken;\n};\n\n/**\n * Clear all queries in client's cache\n * @return undefined\n */\nAlgoliaSearchCore.prototype.clearCache = function() {\n  this.cache = {};\n};\n\n/**\n* Set the number of milliseconds a request can take before automatically being terminated.\n* @deprecated\n* @param {Number} milliseconds\n*/\nAlgoliaSearchCore.prototype.setRequestTimeout = function(milliseconds) {\n  if (milliseconds) {\n    this._timeouts.connect = this._timeouts.read = this._timeouts.write = milliseconds;\n  }\n};\n\n/**\n* Set the three different (connect, read, write) timeouts to be used when requesting\n* @param {Object} timeouts\n*/\nAlgoliaSearchCore.prototype.setTimeouts = function(timeouts) {\n  this._timeouts = timeouts;\n};\n\n/**\n* Get the three different (connect, read, write) timeouts to be used when requesting\n* @param {Object} timeouts\n*/\nAlgoliaSearchCore.prototype.getTimeouts = function() {\n  return this._timeouts;\n};\n\nAlgoliaSearchCore.prototype._getAppIdData = function() {\n  var data = store.get(this.applicationID);\n  if (data !== null) this._cacheAppIdData(data);\n  return data;\n};\n\nAlgoliaSearchCore.prototype._setAppIdData = function(data) {\n  data.lastChange = (new Date()).getTime();\n  this._cacheAppIdData(data);\n  return store.set(this.applicationID, data);\n};\n\nAlgoliaSearchCore.prototype._checkAppIdData = function() {\n  var data = this._getAppIdData();\n  var now = (new Date()).getTime();\n  if (data === null || now - data.lastChange > RESET_APP_DATA_TIMER) {\n    return this._resetInitialAppIdData(data);\n  }\n\n  return data;\n};\n\nAlgoliaSearchCore.prototype._resetInitialAppIdData = function(data) {\n  var newData = data || {};\n  newData.hostIndexes = {read: 0, write: 0};\n  newData.timeoutMultiplier = 1;\n  newData.shuffleResult = newData.shuffleResult || shuffle([1, 2, 3]);\n  return this._setAppIdData(newData);\n};\n\nAlgoliaSearchCore.prototype._cacheAppIdData = function(data) {\n  this._hostIndexes = data.hostIndexes;\n  this._timeoutMultiplier = data.timeoutMultiplier;\n  this._shuffleResult = data.shuffleResult;\n};\n\nAlgoliaSearchCore.prototype._partialAppIdDataUpdate = function(newData) {\n  var foreach = require('foreach');\n  var currentData = this._getAppIdData();\n  foreach(newData, function(value, key) {\n    currentData[key] = value;\n  });\n\n  return this._setAppIdData(currentData);\n};\n\nAlgoliaSearchCore.prototype._getHostByType = function(hostType) {\n  return this.hosts[hostType][this._getHostIndexByType(hostType)];\n};\n\nAlgoliaSearchCore.prototype._getTimeoutMultiplier = function() {\n  return this._timeoutMultiplier;\n};\n\nAlgoliaSearchCore.prototype._getHostIndexByType = function(hostType) {\n  return this._hostIndexes[hostType];\n};\n\nAlgoliaSearchCore.prototype._setHostIndexByType = function(hostIndex, hostType) {\n  var clone = require('./clone');\n  var newHostIndexes = clone(this._hostIndexes);\n  newHostIndexes[hostType] = hostIndex;\n  this._partialAppIdDataUpdate({hostIndexes: newHostIndexes});\n  return hostIndex;\n};\n\nAlgoliaSearchCore.prototype._incrementHostIndex = function(hostType) {\n  return this._setHostIndexByType(\n    (this._getHostIndexByType(hostType) + 1) % this.hosts[hostType].length, hostType\n  );\n};\n\nAlgoliaSearchCore.prototype._incrementTimeoutMultipler = function() {\n  var timeoutMultiplier = Math.max(this._timeoutMultiplier + 1, 4);\n  return this._partialAppIdDataUpdate({timeoutMultiplier: timeoutMultiplier});\n};\n\nAlgoliaSearchCore.prototype._getTimeoutsForRequest = function(hostType) {\n  return {\n    connect: this._timeouts.connect * this._timeoutMultiplier,\n    complete: this._timeouts[hostType] * this._timeoutMultiplier\n  };\n};\n\nfunction prepareHost(protocol) {\n  return function prepare(host) {\n    return protocol + '//' + host.toLowerCase();\n  };\n}\n\n// Prototype.js < 1.7, a widely used library, defines a weird\n// Array.prototype.toJSON function that will fail to stringify our content\n// appropriately\n// refs:\n//   - https://groups.google.com/forum/#!topic/prototype-core/E-SAVvV_V9Q\n//   - https://github.com/sstephenson/prototype/commit/038a2985a70593c1a86c230fadbdfe2e4898a48c\n//   - http://stackoverflow.com/a/3148441/147079\nfunction safeJSONStringify(obj) {\n  /* eslint no-extend-native:0 */\n\n  if (Array.prototype.toJSON === undefined) {\n    return JSON.stringify(obj);\n  }\n\n  var toJSON = Array.prototype.toJSON;\n  delete Array.prototype.toJSON;\n  var out = JSON.stringify(obj);\n  Array.prototype.toJSON = toJSON;\n\n  return out;\n}\n\nfunction shuffle(array) {\n  var currentIndex = array.length;\n  var temporaryValue;\n  var randomIndex;\n\n  // While there remain elements to shuffle...\n  while (currentIndex !== 0) {\n    // Pick a remaining element...\n    randomIndex = Math.floor(Math.random() * currentIndex);\n    currentIndex -= 1;\n\n    // And swap it with the current element.\n    temporaryValue = array[currentIndex];\n    array[currentIndex] = array[randomIndex];\n    array[randomIndex] = temporaryValue;\n  }\n\n  return array;\n}\n\nfunction removeCredentials(headers) {\n  var newHeaders = {};\n\n  for (var headerName in headers) {\n    if (Object.prototype.hasOwnProperty.call(headers, headerName)) {\n      var value;\n\n      if (headerName === 'x-algolia-api-key' || headerName === 'x-algolia-application-id') {\n        value = '**hidden for security purposes**';\n      } else {\n        value = headers[headerName];\n      }\n\n      newHeaders[headerName] = value;\n    }\n  }\n\n  return newHeaders;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}