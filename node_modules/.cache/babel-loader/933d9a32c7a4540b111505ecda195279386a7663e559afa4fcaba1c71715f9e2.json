{"ast":null,"code":"'use strict';\n\nmodule.exports = generateTrees;\nvar orderBy = require('../functions/orderBy');\nvar find = require('../functions/find');\nvar prepareHierarchicalFacetSortBy = require('../functions/formatSort');\nvar fv = require('../functions/escapeFacetValue');\nvar escapeFacetValue = fv.escapeFacetValue;\nvar unescapeFacetValue = fv.unescapeFacetValue;\nfunction generateTrees(state) {\n  return function generate(hierarchicalFacetResult, hierarchicalFacetIndex) {\n    var hierarchicalFacet = state.hierarchicalFacets[hierarchicalFacetIndex];\n    var hierarchicalFacetRefinement = state.hierarchicalFacetsRefinements[hierarchicalFacet.name] && state.hierarchicalFacetsRefinements[hierarchicalFacet.name][0] || '';\n    var hierarchicalSeparator = state._getHierarchicalFacetSeparator(hierarchicalFacet);\n    var hierarchicalRootPath = state._getHierarchicalRootPath(hierarchicalFacet);\n    var hierarchicalShowParentLevel = state._getHierarchicalShowParentLevel(hierarchicalFacet);\n    var sortBy = prepareHierarchicalFacetSortBy(state._getHierarchicalFacetSortBy(hierarchicalFacet));\n    var rootExhaustive = hierarchicalFacetResult.every(function (facetResult) {\n      return facetResult.exhaustive;\n    });\n    var generateTreeFn = generateHierarchicalTree(sortBy, hierarchicalSeparator, hierarchicalRootPath, hierarchicalShowParentLevel, hierarchicalFacetRefinement);\n    var results = hierarchicalFacetResult;\n    if (hierarchicalRootPath) {\n      results = hierarchicalFacetResult.slice(hierarchicalRootPath.split(hierarchicalSeparator).length);\n    }\n    return results.reduce(generateTreeFn, {\n      name: state.hierarchicalFacets[hierarchicalFacetIndex].name,\n      count: null,\n      // root level, no count\n      isRefined: true,\n      // root level, always refined\n      path: null,\n      // root level, no path\n      escapedValue: null,\n      exhaustive: rootExhaustive,\n      data: null\n    });\n  };\n}\nfunction generateHierarchicalTree(sortBy, hierarchicalSeparator, hierarchicalRootPath, hierarchicalShowParentLevel, currentRefinement) {\n  return function generateTree(hierarchicalTree, hierarchicalFacetResult, currentHierarchicalLevel) {\n    var parent = hierarchicalTree;\n    if (currentHierarchicalLevel > 0) {\n      var level = 0;\n      parent = hierarchicalTree;\n      while (level < currentHierarchicalLevel) {\n        /**\n         * @type {object[]]} hierarchical data\n         */\n        var data = parent && Array.isArray(parent.data) ? parent.data : [];\n        parent = find(data, function (subtree) {\n          return subtree.isRefined;\n        });\n        level++;\n      }\n    }\n\n    // we found a refined parent, let's add current level data under it\n    if (parent) {\n      // filter values in case an object has multiple categories:\n      //   {\n      //     categories: {\n      //       level0: ['beers', 'bières'],\n      //       level1: ['beers > IPA', 'bières > Belges']\n      //     }\n      //   }\n      //\n      // If parent refinement is `beers`, then we do not want to have `bières > Belges`\n      // showing up\n\n      var picked = Object.keys(hierarchicalFacetResult.data).map(function (facetValue) {\n        return [facetValue, hierarchicalFacetResult.data[facetValue]];\n      }).filter(function (tuple) {\n        var facetValue = tuple[0];\n        return onlyMatchingTree(facetValue, parent.path || hierarchicalRootPath, currentRefinement, hierarchicalSeparator, hierarchicalRootPath, hierarchicalShowParentLevel);\n      });\n      parent.data = orderBy(picked.map(function (tuple) {\n        var facetValue = tuple[0];\n        var facetCount = tuple[1];\n        return format(facetCount, facetValue, hierarchicalSeparator, unescapeFacetValue(currentRefinement), hierarchicalFacetResult.exhaustive);\n      }), sortBy[0], sortBy[1]);\n    }\n    return hierarchicalTree;\n  };\n}\nfunction onlyMatchingTree(facetValue, parentPath, currentRefinement, hierarchicalSeparator, hierarchicalRootPath, hierarchicalShowParentLevel) {\n  // we want the facetValue is a child of hierarchicalRootPath\n  if (hierarchicalRootPath && (facetValue.indexOf(hierarchicalRootPath) !== 0 || hierarchicalRootPath === facetValue)) {\n    return false;\n  }\n\n  // we always want root levels (only when there is no prefix path)\n  return !hierarchicalRootPath && facetValue.indexOf(hierarchicalSeparator) === -1 ||\n  // if there is a rootPath, being root level mean 1 level under rootPath\n  hierarchicalRootPath && facetValue.split(hierarchicalSeparator).length - hierarchicalRootPath.split(hierarchicalSeparator).length === 1 ||\n  // if current refinement is a root level and current facetValue is a root level,\n  // keep the facetValue\n  facetValue.indexOf(hierarchicalSeparator) === -1 && currentRefinement.indexOf(hierarchicalSeparator) === -1 ||\n  // currentRefinement is a child of the facet value\n  currentRefinement.indexOf(facetValue) === 0 ||\n  // facetValue is a child of the current parent, add it\n  facetValue.indexOf(parentPath + hierarchicalSeparator) === 0 && (hierarchicalShowParentLevel || facetValue.indexOf(currentRefinement) === 0);\n}\nfunction format(facetCount, facetValue, hierarchicalSeparator, currentRefinement, exhaustive) {\n  var parts = facetValue.split(hierarchicalSeparator);\n  return {\n    name: parts[parts.length - 1].trim(),\n    path: facetValue,\n    escapedValue: escapeFacetValue(facetValue),\n    count: facetCount,\n    isRefined: currentRefinement === facetValue || currentRefinement.indexOf(facetValue + hierarchicalSeparator) === 0,\n    exhaustive: exhaustive,\n    data: null\n  };\n}","map":{"version":3,"names":["module","exports","generateTrees","orderBy","require","find","prepareHierarchicalFacetSortBy","fv","escapeFacetValue","unescapeFacetValue","state","generate","hierarchicalFacetResult","hierarchicalFacetIndex","hierarchicalFacet","hierarchicalFacets","hierarchicalFacetRefinement","hierarchicalFacetsRefinements","name","hierarchicalSeparator","_getHierarchicalFacetSeparator","hierarchicalRootPath","_getHierarchicalRootPath","hierarchicalShowParentLevel","_getHierarchicalShowParentLevel","sortBy","_getHierarchicalFacetSortBy","rootExhaustive","every","facetResult","exhaustive","generateTreeFn","generateHierarchicalTree","results","slice","split","length","reduce","count","isRefined","path","escapedValue","data","currentRefinement","generateTree","hierarchicalTree","currentHierarchicalLevel","parent","level","Array","isArray","subtree","picked","Object","keys","map","facetValue","filter","tuple","onlyMatchingTree","facetCount","format","parentPath","indexOf","parts","trim"],"sources":["/Users/amandawinkler/Desktop/algolia-instantsearch-react-geo/node_modules/algoliasearch-helper/src/SearchResults/generate-hierarchical-tree.js"],"sourcesContent":["'use strict';\n\nmodule.exports = generateTrees;\n\nvar orderBy = require('../functions/orderBy');\nvar find = require('../functions/find');\nvar prepareHierarchicalFacetSortBy = require('../functions/formatSort');\nvar fv = require('../functions/escapeFacetValue');\nvar escapeFacetValue = fv.escapeFacetValue;\nvar unescapeFacetValue = fv.unescapeFacetValue;\n\nfunction generateTrees(state) {\n  return function generate(hierarchicalFacetResult, hierarchicalFacetIndex) {\n    var hierarchicalFacet = state.hierarchicalFacets[hierarchicalFacetIndex];\n    var hierarchicalFacetRefinement =\n      (state.hierarchicalFacetsRefinements[hierarchicalFacet.name] &&\n        state.hierarchicalFacetsRefinements[hierarchicalFacet.name][0]) ||\n      '';\n    var hierarchicalSeparator = state._getHierarchicalFacetSeparator(\n      hierarchicalFacet\n    );\n    var hierarchicalRootPath = state._getHierarchicalRootPath(\n      hierarchicalFacet\n    );\n    var hierarchicalShowParentLevel = state._getHierarchicalShowParentLevel(\n      hierarchicalFacet\n    );\n    var sortBy = prepareHierarchicalFacetSortBy(\n      state._getHierarchicalFacetSortBy(hierarchicalFacet)\n    );\n\n    var rootExhaustive = hierarchicalFacetResult.every(function(facetResult) {\n      return facetResult.exhaustive;\n    });\n\n    var generateTreeFn = generateHierarchicalTree(\n      sortBy,\n      hierarchicalSeparator,\n      hierarchicalRootPath,\n      hierarchicalShowParentLevel,\n      hierarchicalFacetRefinement\n    );\n\n    var results = hierarchicalFacetResult;\n\n    if (hierarchicalRootPath) {\n      results = hierarchicalFacetResult.slice(\n        hierarchicalRootPath.split(hierarchicalSeparator).length\n      );\n    }\n\n    return results.reduce(generateTreeFn, {\n      name: state.hierarchicalFacets[hierarchicalFacetIndex].name,\n      count: null, // root level, no count\n      isRefined: true, // root level, always refined\n      path: null, // root level, no path\n      escapedValue: null,\n      exhaustive: rootExhaustive,\n      data: null\n    });\n  };\n}\n\nfunction generateHierarchicalTree(\n  sortBy,\n  hierarchicalSeparator,\n  hierarchicalRootPath,\n  hierarchicalShowParentLevel,\n  currentRefinement\n) {\n  return function generateTree(\n    hierarchicalTree,\n    hierarchicalFacetResult,\n    currentHierarchicalLevel\n  ) {\n    var parent = hierarchicalTree;\n\n    if (currentHierarchicalLevel > 0) {\n      var level = 0;\n\n      parent = hierarchicalTree;\n\n      while (level < currentHierarchicalLevel) {\n        /**\n         * @type {object[]]} hierarchical data\n         */\n        var data = parent && Array.isArray(parent.data) ? parent.data : [];\n        parent = find(data, function(subtree) {\n          return subtree.isRefined;\n        });\n        level++;\n      }\n    }\n\n    // we found a refined parent, let's add current level data under it\n    if (parent) {\n      // filter values in case an object has multiple categories:\n      //   {\n      //     categories: {\n      //       level0: ['beers', 'bières'],\n      //       level1: ['beers > IPA', 'bières > Belges']\n      //     }\n      //   }\n      //\n      // If parent refinement is `beers`, then we do not want to have `bières > Belges`\n      // showing up\n\n      var picked = Object.keys(hierarchicalFacetResult.data)\n        .map(function(facetValue) {\n          return [facetValue, hierarchicalFacetResult.data[facetValue]];\n        })\n        .filter(function(tuple) {\n          var facetValue = tuple[0];\n          return onlyMatchingTree(\n            facetValue,\n            parent.path || hierarchicalRootPath,\n            currentRefinement,\n            hierarchicalSeparator,\n            hierarchicalRootPath,\n            hierarchicalShowParentLevel\n          );\n        });\n\n      parent.data = orderBy(\n        picked.map(function(tuple) {\n          var facetValue = tuple[0];\n          var facetCount = tuple[1];\n\n          return format(\n            facetCount,\n            facetValue,\n            hierarchicalSeparator,\n            unescapeFacetValue(currentRefinement),\n            hierarchicalFacetResult.exhaustive\n          );\n        }),\n        sortBy[0],\n        sortBy[1]\n      );\n    }\n\n    return hierarchicalTree;\n  };\n}\n\nfunction onlyMatchingTree(\n  facetValue,\n  parentPath,\n  currentRefinement,\n  hierarchicalSeparator,\n  hierarchicalRootPath,\n  hierarchicalShowParentLevel\n) {\n  // we want the facetValue is a child of hierarchicalRootPath\n  if (\n    hierarchicalRootPath &&\n    (facetValue.indexOf(hierarchicalRootPath) !== 0 ||\n      hierarchicalRootPath === facetValue)\n  ) {\n    return false;\n  }\n\n  // we always want root levels (only when there is no prefix path)\n  return (\n    (!hierarchicalRootPath &&\n      facetValue.indexOf(hierarchicalSeparator) === -1) ||\n    // if there is a rootPath, being root level mean 1 level under rootPath\n    (hierarchicalRootPath &&\n      facetValue.split(hierarchicalSeparator).length -\n        hierarchicalRootPath.split(hierarchicalSeparator).length ===\n        1) ||\n    // if current refinement is a root level and current facetValue is a root level,\n    // keep the facetValue\n    (facetValue.indexOf(hierarchicalSeparator) === -1 &&\n      currentRefinement.indexOf(hierarchicalSeparator) === -1) ||\n    // currentRefinement is a child of the facet value\n    currentRefinement.indexOf(facetValue) === 0 ||\n    // facetValue is a child of the current parent, add it\n    (facetValue.indexOf(parentPath + hierarchicalSeparator) === 0 &&\n      (hierarchicalShowParentLevel ||\n        facetValue.indexOf(currentRefinement) === 0))\n  );\n}\n\nfunction format(\n  facetCount,\n  facetValue,\n  hierarchicalSeparator,\n  currentRefinement,\n  exhaustive\n) {\n  var parts = facetValue.split(hierarchicalSeparator);\n  return {\n    name: parts[parts.length - 1].trim(),\n    path: facetValue,\n    escapedValue: escapeFacetValue(facetValue),\n    count: facetCount,\n    isRefined:\n      currentRefinement === facetValue ||\n      currentRefinement.indexOf(facetValue + hierarchicalSeparator) === 0,\n    exhaustive: exhaustive,\n    data: null\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}