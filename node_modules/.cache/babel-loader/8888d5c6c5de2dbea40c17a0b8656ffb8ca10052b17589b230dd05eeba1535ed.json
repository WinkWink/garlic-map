{"ast":null,"code":"var _excluded = [\"resultsFacetValues\"],\n  _excluded2 = [\"resultsFacetValues\"],\n  _excluded3 = [\"resultsFacetValues\"];\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n  return target;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return _typeof(key) === \"symbol\" ? key : String(key);\n}\nfunction _toPrimitive(input, hint) {\n  if (_typeof(input) !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (_typeof(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\nimport algoliasearchHelper from 'algoliasearch-helper';\nimport createWidgetsManager from \"./createWidgetsManager.js\";\nimport createStore from \"./createStore.js\";\nimport { HIGHLIGHT_TAGS } from \"./highlight.js\";\nimport { hasMultipleIndices } from \"./indexUtils.js\";\nimport { version as ReactVersion } from 'react';\nimport version from \"./version.js\";\nfunction addAlgoliaAgents(searchClient) {\n  if (typeof searchClient.addAlgoliaAgent === 'function') {\n    searchClient.addAlgoliaAgent(\"react (\".concat(ReactVersion, \")\"));\n    searchClient.addAlgoliaAgent(\"react-instantsearch (\".concat(version, \")\"));\n  }\n}\nvar isMultiIndexContext = function isMultiIndexContext(widget) {\n  return hasMultipleIndices({\n    ais: widget.props.contextValue,\n    multiIndexContext: widget.props.indexContextValue\n  });\n};\nvar isTargetedIndexEqualIndex = function isTargetedIndexEqualIndex(widget, indexId) {\n  return widget.props.indexContextValue.targetedIndex === indexId;\n};\n\n// Relying on the `indexId` is a bit brittle to detect the `Index` widget.\n// Since it's a class we could rely on `instanceof` or similar. We never\n// had an issue though. Works for now.\nvar isIndexWidget = function isIndexWidget(widget) {\n  return Boolean(widget.props.indexId);\n};\nvar isIndexWidgetEqualIndex = function isIndexWidgetEqualIndex(widget, indexId) {\n  return widget.props.indexId === indexId;\n};\nvar sortIndexWidgetsFirst = function sortIndexWidgetsFirst(firstWidget, secondWidget) {\n  var isFirstWidgetIndex = isIndexWidget(firstWidget);\n  var isSecondWidgetIndex = isIndexWidget(secondWidget);\n  if (isFirstWidgetIndex && !isSecondWidgetIndex) {\n    return -1;\n  }\n  if (!isFirstWidgetIndex && isSecondWidgetIndex) {\n    return 1;\n  }\n  return 0;\n};\n\n// This function is copied from the algoliasearch v4 API Client. If modified,\n// consider updating it also in `serializeQueryParameters` from `@algolia/transporter`.\nfunction serializeQueryParameters(parameters) {\n  var isObjectOrArray = function isObjectOrArray(value) {\n    return Object.prototype.toString.call(value) === '[object Object]' || Object.prototype.toString.call(value) === '[object Array]';\n  };\n  var encode = function encode(format) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n    var i = 0;\n    return format.replace(/%s/g, function () {\n      return encodeURIComponent(args[i++]);\n    });\n  };\n  return Object.keys(parameters).map(function (key) {\n    return encode('%s=%s', key, isObjectOrArray(parameters[key]) ? JSON.stringify(parameters[key]) : parameters[key]);\n  }).join('&');\n}\n\n/**\n * Creates a new instance of the InstantSearchManager which controls the widgets and\n * trigger the search when the widgets are updated.\n * @param {string} indexName - the main index name\n * @param {object} initialState - initial widget state\n * @param {object} SearchParameters - optional additional parameters to send to the algolia API\n * @param {number} stalledSearchDelay - time (in ms) after the search is stalled\n * @return {InstantSearchManager} a new instance of InstantSearchManager\n */\nexport default function createInstantSearchManager(_ref) {\n  var indexName = _ref.indexName,\n    _ref$initialState = _ref.initialState,\n    initialState = _ref$initialState === void 0 ? {} : _ref$initialState,\n    searchClient = _ref.searchClient,\n    resultsState = _ref.resultsState,\n    stalledSearchDelay = _ref.stalledSearchDelay;\n  var helper = algoliasearchHelper(searchClient, indexName, _objectSpread({}, HIGHLIGHT_TAGS));\n  addAlgoliaAgents(searchClient);\n  helper.on('search', handleNewSearch).on('result', handleSearchSuccess({\n    indexId: indexName\n  })).on('error', handleSearchError);\n  var skip = false;\n  var stalledSearchTimer = null;\n  var initialSearchParameters = helper.state;\n  var searchCounter;\n  var widgetsManager = createWidgetsManager(onWidgetsUpdate);\n  hydrateSearchClient(searchClient, resultsState);\n  var store = createStore({\n    widgets: initialState,\n    metadata: hydrateMetadata(resultsState),\n    results: hydrateResultsState(resultsState),\n    error: null,\n    searching: false,\n    isSearchStalled: true,\n    searchingForFacetValues: false\n  });\n  function skipSearch() {\n    skip = true;\n  }\n  function updateClient(client) {\n    addAlgoliaAgents(client);\n    helper.setClient(client);\n    search();\n  }\n  function clearCache() {\n    helper.clearCache();\n    search();\n  }\n  function getMetadata(state) {\n    return widgetsManager.getWidgets().filter(function (widget) {\n      return Boolean(widget.getMetadata);\n    }).map(function (widget) {\n      return widget.getMetadata(state);\n    });\n  }\n  function getSearchParameters() {\n    var sharedParameters = widgetsManager.getWidgets().filter(function (widget) {\n      return Boolean(widget.getSearchParameters);\n    }).filter(function (widget) {\n      return !isMultiIndexContext(widget) && !isIndexWidget(widget);\n    }).reduce(function (res, widget) {\n      return widget.getSearchParameters(res);\n    }, initialSearchParameters);\n    var mainParameters = widgetsManager.getWidgets().filter(function (widget) {\n      return Boolean(widget.getSearchParameters);\n    }).filter(function (widget) {\n      var targetedIndexEqualMainIndex = isMultiIndexContext(widget) && isTargetedIndexEqualIndex(widget, indexName);\n      var subIndexEqualMainIndex = isIndexWidget(widget) && isIndexWidgetEqualIndex(widget, indexName);\n      return targetedIndexEqualMainIndex || subIndexEqualMainIndex;\n    })\n    // We have to sort the `Index` widgets first so the `index` parameter\n    // is correctly set in the `reduce` function for the following widgets\n    .sort(sortIndexWidgetsFirst).reduce(function (res, widget) {\n      return widget.getSearchParameters(res);\n    }, sharedParameters);\n    var derivedIndices = widgetsManager.getWidgets().filter(function (widget) {\n      return Boolean(widget.getSearchParameters);\n    }).filter(function (widget) {\n      var targetedIndexNotEqualMainIndex = isMultiIndexContext(widget) && !isTargetedIndexEqualIndex(widget, indexName);\n      var subIndexNotEqualMainIndex = isIndexWidget(widget) && !isIndexWidgetEqualIndex(widget, indexName);\n      return targetedIndexNotEqualMainIndex || subIndexNotEqualMainIndex;\n    })\n    // We have to sort the `Index` widgets first so the `index` parameter\n    // is correctly set in the `reduce` function for the following widgets\n    .sort(sortIndexWidgetsFirst).reduce(function (indices, widget) {\n      var indexId = isMultiIndexContext(widget) ? widget.props.indexContextValue.targetedIndex : widget.props.indexId;\n      var widgets = indices[indexId] || [];\n      return _objectSpread(_objectSpread({}, indices), {}, _defineProperty({}, indexId, widgets.concat(widget)));\n    }, {});\n    var derivedParameters = Object.keys(derivedIndices).map(function (indexId) {\n      return {\n        parameters: derivedIndices[indexId].reduce(function (res, widget) {\n          return widget.getSearchParameters(res);\n        }, sharedParameters),\n        indexId: indexId\n      };\n    });\n    return {\n      mainParameters: mainParameters,\n      derivedParameters: derivedParameters\n    };\n  }\n  function search() {\n    if (!skip) {\n      var _getSearchParameters = getSearchParameters(helper.state),\n        mainParameters = _getSearchParameters.mainParameters,\n        derivedParameters = _getSearchParameters.derivedParameters;\n      searchCounter = derivedParameters.length + 1;\n\n      // We have to call `slice` because the method `detach` on the derived\n      // helpers mutates the value `derivedHelpers`. The `forEach` loop does\n      // not iterate on each value and we're not able to correctly clear the\n      // previous derived helpers (memory leak + useless requests).\n      helper.derivedHelpers.slice().forEach(function (derivedHelper) {\n        // Since we detach the derived helpers on **every** new search they\n        // won't receive intermediate results in case of a stalled search.\n        // Only the last result is dispatched by the derived helper because\n        // they are not detached yet:\n        //\n        // - a -> main helper receives results\n        // - ap -> main helper receives results\n        // - app -> main helper + derived helpers receive results\n        //\n        // The quick fix is to avoid to detach them on search but only once they\n        // received the results. But it means that in case of a stalled search\n        // all the derived helpers not detached yet register a new search inside\n        // the helper. The number grows fast in case of a bad network and it's\n        // not deterministic.\n        derivedHelper.detach();\n      });\n      derivedParameters.forEach(function (_ref2) {\n        var indexId = _ref2.indexId,\n          parameters = _ref2.parameters;\n        var derivedHelper = helper.derive(function () {\n          return parameters;\n        });\n        derivedHelper.on('result', handleSearchSuccess({\n          indexId: indexId\n        })).on('error', handleSearchError);\n      });\n      helper.setState(mainParameters);\n      helper.search();\n    }\n  }\n  function handleSearchSuccess(_ref3) {\n    var indexId = _ref3.indexId;\n    return function (event) {\n      searchCounter--;\n      var state = store.getState();\n      var isDerivedHelpersEmpty = !helper.derivedHelpers.length;\n      var results = state.results ? state.results : {};\n\n      // Switching from mono index to multi index and vice versa must reset the\n      // results to an empty object, otherwise we keep reference of stalled and\n      // unused results.\n      results = !isDerivedHelpersEmpty && results.getFacetByName ? {} : results;\n      if (!isDerivedHelpersEmpty) {\n        results = _objectSpread(_objectSpread({}, results), {}, _defineProperty({}, indexId, event.results));\n      } else {\n        results = event.results;\n      }\n      var currentState = store.getState();\n      var nextIsSearchStalled = currentState.isSearchStalled;\n      if (!helper.hasPendingRequests()) {\n        clearTimeout(stalledSearchTimer);\n        stalledSearchTimer = null;\n        nextIsSearchStalled = false;\n      }\n      var resultsFacetValues = currentState.resultsFacetValues,\n        partialState = _objectWithoutProperties(currentState, _excluded);\n      store.setState(_objectSpread(_objectSpread({}, partialState), {}, {\n        results: results,\n        isSearchStalled: nextIsSearchStalled,\n        searching: searchCounter > 0,\n        error: null\n      }));\n    };\n  }\n  function handleSearchError(_ref4) {\n    var error = _ref4.error;\n    var currentState = store.getState();\n    var nextIsSearchStalled = currentState.isSearchStalled;\n    if (!helper.hasPendingRequests()) {\n      clearTimeout(stalledSearchTimer);\n      nextIsSearchStalled = false;\n    }\n    var resultsFacetValues = currentState.resultsFacetValues,\n      partialState = _objectWithoutProperties(currentState, _excluded2);\n    store.setState(_objectSpread(_objectSpread({}, partialState), {}, {\n      isSearchStalled: nextIsSearchStalled,\n      error: error,\n      searching: false\n    }));\n  }\n  function handleNewSearch() {\n    if (!stalledSearchTimer) {\n      stalledSearchTimer = setTimeout(function () {\n        var _store$getState = store.getState(),\n          resultsFacetValues = _store$getState.resultsFacetValues,\n          partialState = _objectWithoutProperties(_store$getState, _excluded3);\n        store.setState(_objectSpread(_objectSpread({}, partialState), {}, {\n          isSearchStalled: true\n        }));\n      }, stalledSearchDelay);\n    }\n  }\n  function hydrateSearchClient(client, results) {\n    if (!results) {\n      return;\n    }\n\n    // Disable cache hydration on:\n    // - Algoliasearch API Client < v4 with cache disabled\n    // - Third party clients (detected by the `addAlgoliaAgent` function missing)\n\n    if ((!client.transporter || client._cacheHydrated) && (!client._useCache || typeof client.addAlgoliaAgent !== 'function')) {\n      return;\n    }\n\n    // Algoliasearch API Client >= v4\n    // To hydrate the client we need to populate the cache with the data from\n    // the server (done in `hydrateSearchClientWithMultiIndexRequest` or\n    // `hydrateSearchClientWithSingleIndexRequest`). But since there is no way\n    // for us to compute the key the same way as `algoliasearch-client` we need\n    // to populate it on a custom key and override the `search` method to\n    // search on it first.\n    if (client.transporter && !client._cacheHydrated) {\n      client._cacheHydrated = true;\n      var baseMethod = client.search;\n      client.search = function (requests) {\n        for (var _len2 = arguments.length, methodArgs = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n          methodArgs[_key2 - 1] = arguments[_key2];\n        }\n        var requestsWithSerializedParams = requests.map(function (request) {\n          return _objectSpread(_objectSpread({}, request), {}, {\n            params: serializeQueryParameters(request.params)\n          });\n        });\n        return client.transporter.responsesCache.get({\n          method: 'search',\n          args: [requestsWithSerializedParams].concat(methodArgs)\n        }, function () {\n          return baseMethod.apply(void 0, [requests].concat(methodArgs));\n        });\n      };\n    }\n    if (Array.isArray(results.results)) {\n      hydrateSearchClientWithMultiIndexRequest(client, results.results);\n      return;\n    }\n    hydrateSearchClientWithSingleIndexRequest(client, results);\n  }\n  function hydrateSearchClientWithMultiIndexRequest(client, results) {\n    // Algoliasearch API Client >= v4\n    // Populate the cache with the data from the server\n    if (client.transporter) {\n      client.transporter.responsesCache.set({\n        method: 'search',\n        args: [results.reduce(function (acc, result) {\n          return acc.concat(result.rawResults.map(function (request) {\n            return {\n              indexName: request.index,\n              params: request.params\n            };\n          }));\n        }, [])]\n      }, {\n        results: results.reduce(function (acc, result) {\n          return acc.concat(result.rawResults);\n        }, [])\n      });\n      return;\n    }\n\n    // Algoliasearch API Client < v4\n    // Prior to client v4 we didn't have a proper API to hydrate the client\n    // cache from the outside. The following code populates the cache with\n    // a single-index result. You can find more information about the\n    // computation of the key inside the client (see link below).\n    // https://github.com/algolia/algoliasearch-client-javascript/blob/c27e89ff92b2a854ae6f40dc524bffe0f0cbc169/src/AlgoliaSearchCore.js#L232-L240\n    var key = \"/1/indexes/*/queries_body_\".concat(JSON.stringify({\n      requests: results.reduce(function (acc, result) {\n        return acc.concat(result.rawResults.map(function (request) {\n          return {\n            indexName: request.index,\n            params: request.params\n          };\n        }));\n      }, [])\n    }));\n    client.cache = _objectSpread(_objectSpread({}, client.cache), {}, _defineProperty({}, key, JSON.stringify({\n      results: results.reduce(function (acc, result) {\n        return acc.concat(result.rawResults);\n      }, [])\n    })));\n  }\n  function hydrateSearchClientWithSingleIndexRequest(client, results) {\n    // Algoliasearch API Client >= v4\n    // Populate the cache with the data from the server\n    if (client.transporter) {\n      client.transporter.responsesCache.set({\n        method: 'search',\n        args: [results.rawResults.map(function (request) {\n          return {\n            indexName: request.index,\n            params: request.params\n          };\n        })]\n      }, {\n        results: results.rawResults\n      });\n      return;\n    }\n    // Algoliasearch API Client < v4\n    // Prior to client v4 we didn't have a proper API to hydrate the client\n    // cache from the outside. The following code populates the cache with\n    // a single-index result. You can find more information about the\n    // computation of the key inside the client (see link below).\n    // https://github.com/algolia/algoliasearch-client-javascript/blob/c27e89ff92b2a854ae6f40dc524bffe0f0cbc169/src/AlgoliaSearchCore.js#L232-L240\n    var key = \"/1/indexes/*/queries_body_\".concat(JSON.stringify({\n      requests: results.rawResults.map(function (request) {\n        return {\n          indexName: request.index,\n          params: request.params\n        };\n      })\n    }));\n    client.cache = _objectSpread(_objectSpread({}, client.cache), {}, _defineProperty({}, key, JSON.stringify({\n      results: results.rawResults\n    })));\n  }\n  function hydrateResultsState(results) {\n    if (!results) {\n      return null;\n    }\n    if (Array.isArray(results.results)) {\n      return results.results.reduce(function (acc, result) {\n        return _objectSpread(_objectSpread({}, acc), {}, _defineProperty({}, result._internalIndexId, new algoliasearchHelper.SearchResults(new algoliasearchHelper.SearchParameters(result.state), result.rawResults)));\n      }, {});\n    }\n    return new algoliasearchHelper.SearchResults(new algoliasearchHelper.SearchParameters(results.state), results.rawResults);\n  }\n\n  // Called whenever a widget has been rendered with new props.\n  function onWidgetsUpdate() {\n    var metadata = getMetadata(store.getState().widgets);\n    store.setState(_objectSpread(_objectSpread({}, store.getState()), {}, {\n      metadata: metadata,\n      searching: true\n    }));\n\n    // Since the `getSearchParameters` method of widgets also depends on props,\n    // the result search parameters might have changed.\n    search();\n  }\n  function transitionState(nextSearchState) {\n    var searchState = store.getState().widgets;\n    return widgetsManager.getWidgets().filter(function (widget) {\n      return Boolean(widget.transitionState);\n    }).reduce(function (res, widget) {\n      return widget.transitionState(searchState, res);\n    }, nextSearchState);\n  }\n  function onExternalStateUpdate(nextSearchState) {\n    var metadata = getMetadata(nextSearchState);\n    store.setState(_objectSpread(_objectSpread({}, store.getState()), {}, {\n      widgets: nextSearchState,\n      metadata: metadata,\n      searching: true\n    }));\n    search();\n  }\n  function onSearchForFacetValues(_ref5) {\n    var facetName = _ref5.facetName,\n      query = _ref5.query,\n      _ref5$maxFacetHits = _ref5.maxFacetHits,\n      maxFacetHits = _ref5$maxFacetHits === void 0 ? 10 : _ref5$maxFacetHits;\n    // The values 1, 100 are the min / max values that the engine accepts.\n    // see: https://www.algolia.com/doc/api-reference/api-parameters/maxFacetHits\n    var maxFacetHitsWithinRange = Math.max(1, Math.min(maxFacetHits, 100));\n    store.setState(_objectSpread(_objectSpread({}, store.getState()), {}, {\n      searchingForFacetValues: true\n    }));\n    helper.searchForFacetValues(facetName, query, maxFacetHitsWithinRange).then(function (content) {\n      var _objectSpread7;\n      store.setState(_objectSpread(_objectSpread({}, store.getState()), {}, {\n        error: null,\n        searchingForFacetValues: false,\n        resultsFacetValues: _objectSpread(_objectSpread({}, store.getState().resultsFacetValues), {}, (_objectSpread7 = {}, _defineProperty(_objectSpread7, facetName, content.facetHits), _defineProperty(_objectSpread7, \"query\", query), _objectSpread7))\n      }));\n    }, function (error) {\n      store.setState(_objectSpread(_objectSpread({}, store.getState()), {}, {\n        searchingForFacetValues: false,\n        error: error\n      }));\n    }).catch(function (error) {\n      // Since setState is synchronous, any error that occurs in the render of a\n      // component will be swallowed by this promise.\n      // This is a trick to make the error show up correctly in the console.\n      // See http://stackoverflow.com/a/30741722/969302\n      setTimeout(function () {\n        throw error;\n      });\n    });\n  }\n  function updateIndex(newIndex) {\n    initialSearchParameters = initialSearchParameters.setIndex(newIndex);\n    // No need to trigger a new search here as the widgets will also update and trigger it if needed.\n  }\n\n  function getWidgetsIds() {\n    return store.getState().metadata.reduce(function (res, meta) {\n      return typeof meta.id !== 'undefined' ? res.concat(meta.id) : res;\n    }, []);\n  }\n  return {\n    store: store,\n    widgetsManager: widgetsManager,\n    getWidgetsIds: getWidgetsIds,\n    getSearchParameters: getSearchParameters,\n    onSearchForFacetValues: onSearchForFacetValues,\n    onExternalStateUpdate: onExternalStateUpdate,\n    transitionState: transitionState,\n    updateClient: updateClient,\n    updateIndex: updateIndex,\n    clearCache: clearCache,\n    skipSearch: skipSearch\n  };\n}\nfunction hydrateMetadata(resultsState) {\n  if (!resultsState) {\n    return [];\n  }\n\n  // add a value noop, which gets replaced once the widgets are mounted\n  return resultsState.metadata.map(function (datum) {\n    return _objectSpread(_objectSpread({\n      value: function value() {\n        return {};\n      }\n    }, datum), {}, {\n      items: datum.items && datum.items.map(function (item) {\n        return _objectSpread(_objectSpread({\n          value: function value() {\n            return {};\n          }\n        }, item), {}, {\n          items: item.items && item.items.map(function (nestedItem) {\n            return _objectSpread({\n              value: function value() {\n                return {};\n              }\n            }, nestedItem);\n          })\n        });\n      })\n    });\n  });\n}","map":{"version":3,"names":["_excluded","_excluded2","_excluded3","_typeof","obj","Symbol","iterator","constructor","prototype","_objectWithoutProperties","source","excluded","target","_objectWithoutPropertiesLoose","key","i","Object","getOwnPropertySymbols","sourceSymbolKeys","length","indexOf","propertyIsEnumerable","call","sourceKeys","keys","ownKeys","object","enumerableOnly","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","arguments","forEach","_defineProperty","getOwnPropertyDescriptors","defineProperties","defineProperty","value","_toPropertyKey","configurable","writable","arg","_toPrimitive","String","input","hint","prim","toPrimitive","undefined","res","TypeError","Number","algoliasearchHelper","createWidgetsManager","createStore","HIGHLIGHT_TAGS","hasMultipleIndices","version","ReactVersion","addAlgoliaAgents","searchClient","addAlgoliaAgent","concat","isMultiIndexContext","widget","ais","props","contextValue","multiIndexContext","indexContextValue","isTargetedIndexEqualIndex","indexId","targetedIndex","isIndexWidget","Boolean","isIndexWidgetEqualIndex","sortIndexWidgetsFirst","firstWidget","secondWidget","isFirstWidgetIndex","isSecondWidgetIndex","serializeQueryParameters","parameters","isObjectOrArray","toString","encode","format","_len","args","Array","_key","replace","encodeURIComponent","map","JSON","stringify","join","createInstantSearchManager","_ref","indexName","_ref$initialState","initialState","resultsState","stalledSearchDelay","helper","on","handleNewSearch","handleSearchSuccess","handleSearchError","skip","stalledSearchTimer","initialSearchParameters","state","searchCounter","widgetsManager","onWidgetsUpdate","hydrateSearchClient","store","widgets","metadata","hydrateMetadata","results","hydrateResultsState","error","searching","isSearchStalled","searchingForFacetValues","skipSearch","updateClient","client","setClient","search","clearCache","getMetadata","getWidgets","getSearchParameters","sharedParameters","reduce","mainParameters","targetedIndexEqualMainIndex","subIndexEqualMainIndex","sort","derivedIndices","targetedIndexNotEqualMainIndex","subIndexNotEqualMainIndex","indices","derivedParameters","_getSearchParameters","derivedHelpers","slice","derivedHelper","detach","_ref2","derive","setState","_ref3","event","getState","isDerivedHelpersEmpty","getFacetByName","currentState","nextIsSearchStalled","hasPendingRequests","clearTimeout","resultsFacetValues","partialState","_ref4","setTimeout","_store$getState","transporter","_cacheHydrated","_useCache","baseMethod","requests","_len2","methodArgs","_key2","requestsWithSerializedParams","request","params","responsesCache","get","method","isArray","hydrateSearchClientWithMultiIndexRequest","hydrateSearchClientWithSingleIndexRequest","set","acc","result","rawResults","index","cache","_internalIndexId","SearchResults","SearchParameters","transitionState","nextSearchState","searchState","onExternalStateUpdate","onSearchForFacetValues","_ref5","facetName","query","_ref5$maxFacetHits","maxFacetHits","maxFacetHitsWithinRange","Math","max","min","searchForFacetValues","then","content","_objectSpread7","facetHits","catch","updateIndex","newIndex","setIndex","getWidgetsIds","meta","id","datum","items","item","nestedItem"],"sources":["/Users/amandawinkler/Desktop/algolia-instantsearch-react-geo/node_modules/react-instantsearch-core/dist/es/core/createInstantSearchManager.js"],"sourcesContent":["var _excluded = [\"resultsFacetValues\"],\n  _excluded2 = [\"resultsFacetValues\"],\n  _excluded3 = [\"resultsFacetValues\"];\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nimport algoliasearchHelper from 'algoliasearch-helper';\nimport createWidgetsManager from \"./createWidgetsManager.js\";\nimport createStore from \"./createStore.js\";\nimport { HIGHLIGHT_TAGS } from \"./highlight.js\";\nimport { hasMultipleIndices } from \"./indexUtils.js\";\nimport { version as ReactVersion } from 'react';\nimport version from \"./version.js\";\nfunction addAlgoliaAgents(searchClient) {\n  if (typeof searchClient.addAlgoliaAgent === 'function') {\n    searchClient.addAlgoliaAgent(\"react (\".concat(ReactVersion, \")\"));\n    searchClient.addAlgoliaAgent(\"react-instantsearch (\".concat(version, \")\"));\n  }\n}\nvar isMultiIndexContext = function isMultiIndexContext(widget) {\n  return hasMultipleIndices({\n    ais: widget.props.contextValue,\n    multiIndexContext: widget.props.indexContextValue\n  });\n};\nvar isTargetedIndexEqualIndex = function isTargetedIndexEqualIndex(widget, indexId) {\n  return widget.props.indexContextValue.targetedIndex === indexId;\n};\n\n// Relying on the `indexId` is a bit brittle to detect the `Index` widget.\n// Since it's a class we could rely on `instanceof` or similar. We never\n// had an issue though. Works for now.\nvar isIndexWidget = function isIndexWidget(widget) {\n  return Boolean(widget.props.indexId);\n};\nvar isIndexWidgetEqualIndex = function isIndexWidgetEqualIndex(widget, indexId) {\n  return widget.props.indexId === indexId;\n};\nvar sortIndexWidgetsFirst = function sortIndexWidgetsFirst(firstWidget, secondWidget) {\n  var isFirstWidgetIndex = isIndexWidget(firstWidget);\n  var isSecondWidgetIndex = isIndexWidget(secondWidget);\n  if (isFirstWidgetIndex && !isSecondWidgetIndex) {\n    return -1;\n  }\n  if (!isFirstWidgetIndex && isSecondWidgetIndex) {\n    return 1;\n  }\n  return 0;\n};\n\n// This function is copied from the algoliasearch v4 API Client. If modified,\n// consider updating it also in `serializeQueryParameters` from `@algolia/transporter`.\nfunction serializeQueryParameters(parameters) {\n  var isObjectOrArray = function isObjectOrArray(value) {\n    return Object.prototype.toString.call(value) === '[object Object]' || Object.prototype.toString.call(value) === '[object Array]';\n  };\n  var encode = function encode(format) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n    var i = 0;\n    return format.replace(/%s/g, function () {\n      return encodeURIComponent(args[i++]);\n    });\n  };\n  return Object.keys(parameters).map(function (key) {\n    return encode('%s=%s', key, isObjectOrArray(parameters[key]) ? JSON.stringify(parameters[key]) : parameters[key]);\n  }).join('&');\n}\n\n/**\n * Creates a new instance of the InstantSearchManager which controls the widgets and\n * trigger the search when the widgets are updated.\n * @param {string} indexName - the main index name\n * @param {object} initialState - initial widget state\n * @param {object} SearchParameters - optional additional parameters to send to the algolia API\n * @param {number} stalledSearchDelay - time (in ms) after the search is stalled\n * @return {InstantSearchManager} a new instance of InstantSearchManager\n */\nexport default function createInstantSearchManager(_ref) {\n  var indexName = _ref.indexName,\n    _ref$initialState = _ref.initialState,\n    initialState = _ref$initialState === void 0 ? {} : _ref$initialState,\n    searchClient = _ref.searchClient,\n    resultsState = _ref.resultsState,\n    stalledSearchDelay = _ref.stalledSearchDelay;\n  var helper = algoliasearchHelper(searchClient, indexName, _objectSpread({}, HIGHLIGHT_TAGS));\n  addAlgoliaAgents(searchClient);\n  helper.on('search', handleNewSearch).on('result', handleSearchSuccess({\n    indexId: indexName\n  })).on('error', handleSearchError);\n  var skip = false;\n  var stalledSearchTimer = null;\n  var initialSearchParameters = helper.state;\n  var searchCounter;\n  var widgetsManager = createWidgetsManager(onWidgetsUpdate);\n  hydrateSearchClient(searchClient, resultsState);\n  var store = createStore({\n    widgets: initialState,\n    metadata: hydrateMetadata(resultsState),\n    results: hydrateResultsState(resultsState),\n    error: null,\n    searching: false,\n    isSearchStalled: true,\n    searchingForFacetValues: false\n  });\n  function skipSearch() {\n    skip = true;\n  }\n  function updateClient(client) {\n    addAlgoliaAgents(client);\n    helper.setClient(client);\n    search();\n  }\n  function clearCache() {\n    helper.clearCache();\n    search();\n  }\n  function getMetadata(state) {\n    return widgetsManager.getWidgets().filter(function (widget) {\n      return Boolean(widget.getMetadata);\n    }).map(function (widget) {\n      return widget.getMetadata(state);\n    });\n  }\n  function getSearchParameters() {\n    var sharedParameters = widgetsManager.getWidgets().filter(function (widget) {\n      return Boolean(widget.getSearchParameters);\n    }).filter(function (widget) {\n      return !isMultiIndexContext(widget) && !isIndexWidget(widget);\n    }).reduce(function (res, widget) {\n      return widget.getSearchParameters(res);\n    }, initialSearchParameters);\n    var mainParameters = widgetsManager.getWidgets().filter(function (widget) {\n      return Boolean(widget.getSearchParameters);\n    }).filter(function (widget) {\n      var targetedIndexEqualMainIndex = isMultiIndexContext(widget) && isTargetedIndexEqualIndex(widget, indexName);\n      var subIndexEqualMainIndex = isIndexWidget(widget) && isIndexWidgetEqualIndex(widget, indexName);\n      return targetedIndexEqualMainIndex || subIndexEqualMainIndex;\n    })\n    // We have to sort the `Index` widgets first so the `index` parameter\n    // is correctly set in the `reduce` function for the following widgets\n    .sort(sortIndexWidgetsFirst).reduce(function (res, widget) {\n      return widget.getSearchParameters(res);\n    }, sharedParameters);\n    var derivedIndices = widgetsManager.getWidgets().filter(function (widget) {\n      return Boolean(widget.getSearchParameters);\n    }).filter(function (widget) {\n      var targetedIndexNotEqualMainIndex = isMultiIndexContext(widget) && !isTargetedIndexEqualIndex(widget, indexName);\n      var subIndexNotEqualMainIndex = isIndexWidget(widget) && !isIndexWidgetEqualIndex(widget, indexName);\n      return targetedIndexNotEqualMainIndex || subIndexNotEqualMainIndex;\n    })\n    // We have to sort the `Index` widgets first so the `index` parameter\n    // is correctly set in the `reduce` function for the following widgets\n    .sort(sortIndexWidgetsFirst).reduce(function (indices, widget) {\n      var indexId = isMultiIndexContext(widget) ? widget.props.indexContextValue.targetedIndex : widget.props.indexId;\n      var widgets = indices[indexId] || [];\n      return _objectSpread(_objectSpread({}, indices), {}, _defineProperty({}, indexId, widgets.concat(widget)));\n    }, {});\n    var derivedParameters = Object.keys(derivedIndices).map(function (indexId) {\n      return {\n        parameters: derivedIndices[indexId].reduce(function (res, widget) {\n          return widget.getSearchParameters(res);\n        }, sharedParameters),\n        indexId: indexId\n      };\n    });\n    return {\n      mainParameters: mainParameters,\n      derivedParameters: derivedParameters\n    };\n  }\n  function search() {\n    if (!skip) {\n      var _getSearchParameters = getSearchParameters(helper.state),\n        mainParameters = _getSearchParameters.mainParameters,\n        derivedParameters = _getSearchParameters.derivedParameters;\n      searchCounter = derivedParameters.length + 1;\n\n      // We have to call `slice` because the method `detach` on the derived\n      // helpers mutates the value `derivedHelpers`. The `forEach` loop does\n      // not iterate on each value and we're not able to correctly clear the\n      // previous derived helpers (memory leak + useless requests).\n      helper.derivedHelpers.slice().forEach(function (derivedHelper) {\n        // Since we detach the derived helpers on **every** new search they\n        // won't receive intermediate results in case of a stalled search.\n        // Only the last result is dispatched by the derived helper because\n        // they are not detached yet:\n        //\n        // - a -> main helper receives results\n        // - ap -> main helper receives results\n        // - app -> main helper + derived helpers receive results\n        //\n        // The quick fix is to avoid to detach them on search but only once they\n        // received the results. But it means that in case of a stalled search\n        // all the derived helpers not detached yet register a new search inside\n        // the helper. The number grows fast in case of a bad network and it's\n        // not deterministic.\n        derivedHelper.detach();\n      });\n      derivedParameters.forEach(function (_ref2) {\n        var indexId = _ref2.indexId,\n          parameters = _ref2.parameters;\n        var derivedHelper = helper.derive(function () {\n          return parameters;\n        });\n        derivedHelper.on('result', handleSearchSuccess({\n          indexId: indexId\n        })).on('error', handleSearchError);\n      });\n      helper.setState(mainParameters);\n      helper.search();\n    }\n  }\n  function handleSearchSuccess(_ref3) {\n    var indexId = _ref3.indexId;\n    return function (event) {\n      searchCounter--;\n      var state = store.getState();\n      var isDerivedHelpersEmpty = !helper.derivedHelpers.length;\n      var results = state.results ? state.results : {};\n\n      // Switching from mono index to multi index and vice versa must reset the\n      // results to an empty object, otherwise we keep reference of stalled and\n      // unused results.\n      results = !isDerivedHelpersEmpty && results.getFacetByName ? {} : results;\n      if (!isDerivedHelpersEmpty) {\n        results = _objectSpread(_objectSpread({}, results), {}, _defineProperty({}, indexId, event.results));\n      } else {\n        results = event.results;\n      }\n      var currentState = store.getState();\n      var nextIsSearchStalled = currentState.isSearchStalled;\n      if (!helper.hasPendingRequests()) {\n        clearTimeout(stalledSearchTimer);\n        stalledSearchTimer = null;\n        nextIsSearchStalled = false;\n      }\n      var resultsFacetValues = currentState.resultsFacetValues,\n        partialState = _objectWithoutProperties(currentState, _excluded);\n      store.setState(_objectSpread(_objectSpread({}, partialState), {}, {\n        results: results,\n        isSearchStalled: nextIsSearchStalled,\n        searching: searchCounter > 0,\n        error: null\n      }));\n    };\n  }\n  function handleSearchError(_ref4) {\n    var error = _ref4.error;\n    var currentState = store.getState();\n    var nextIsSearchStalled = currentState.isSearchStalled;\n    if (!helper.hasPendingRequests()) {\n      clearTimeout(stalledSearchTimer);\n      nextIsSearchStalled = false;\n    }\n    var resultsFacetValues = currentState.resultsFacetValues,\n      partialState = _objectWithoutProperties(currentState, _excluded2);\n    store.setState(_objectSpread(_objectSpread({}, partialState), {}, {\n      isSearchStalled: nextIsSearchStalled,\n      error: error,\n      searching: false\n    }));\n  }\n  function handleNewSearch() {\n    if (!stalledSearchTimer) {\n      stalledSearchTimer = setTimeout(function () {\n        var _store$getState = store.getState(),\n          resultsFacetValues = _store$getState.resultsFacetValues,\n          partialState = _objectWithoutProperties(_store$getState, _excluded3);\n        store.setState(_objectSpread(_objectSpread({}, partialState), {}, {\n          isSearchStalled: true\n        }));\n      }, stalledSearchDelay);\n    }\n  }\n  function hydrateSearchClient(client, results) {\n    if (!results) {\n      return;\n    }\n\n    // Disable cache hydration on:\n    // - Algoliasearch API Client < v4 with cache disabled\n    // - Third party clients (detected by the `addAlgoliaAgent` function missing)\n\n    if ((!client.transporter || client._cacheHydrated) && (!client._useCache || typeof client.addAlgoliaAgent !== 'function')) {\n      return;\n    }\n\n    // Algoliasearch API Client >= v4\n    // To hydrate the client we need to populate the cache with the data from\n    // the server (done in `hydrateSearchClientWithMultiIndexRequest` or\n    // `hydrateSearchClientWithSingleIndexRequest`). But since there is no way\n    // for us to compute the key the same way as `algoliasearch-client` we need\n    // to populate it on a custom key and override the `search` method to\n    // search on it first.\n    if (client.transporter && !client._cacheHydrated) {\n      client._cacheHydrated = true;\n      var baseMethod = client.search;\n      client.search = function (requests) {\n        for (var _len2 = arguments.length, methodArgs = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n          methodArgs[_key2 - 1] = arguments[_key2];\n        }\n        var requestsWithSerializedParams = requests.map(function (request) {\n          return _objectSpread(_objectSpread({}, request), {}, {\n            params: serializeQueryParameters(request.params)\n          });\n        });\n        return client.transporter.responsesCache.get({\n          method: 'search',\n          args: [requestsWithSerializedParams].concat(methodArgs)\n        }, function () {\n          return baseMethod.apply(void 0, [requests].concat(methodArgs));\n        });\n      };\n    }\n    if (Array.isArray(results.results)) {\n      hydrateSearchClientWithMultiIndexRequest(client, results.results);\n      return;\n    }\n    hydrateSearchClientWithSingleIndexRequest(client, results);\n  }\n  function hydrateSearchClientWithMultiIndexRequest(client, results) {\n    // Algoliasearch API Client >= v4\n    // Populate the cache with the data from the server\n    if (client.transporter) {\n      client.transporter.responsesCache.set({\n        method: 'search',\n        args: [results.reduce(function (acc, result) {\n          return acc.concat(result.rawResults.map(function (request) {\n            return {\n              indexName: request.index,\n              params: request.params\n            };\n          }));\n        }, [])]\n      }, {\n        results: results.reduce(function (acc, result) {\n          return acc.concat(result.rawResults);\n        }, [])\n      });\n      return;\n    }\n\n    // Algoliasearch API Client < v4\n    // Prior to client v4 we didn't have a proper API to hydrate the client\n    // cache from the outside. The following code populates the cache with\n    // a single-index result. You can find more information about the\n    // computation of the key inside the client (see link below).\n    // https://github.com/algolia/algoliasearch-client-javascript/blob/c27e89ff92b2a854ae6f40dc524bffe0f0cbc169/src/AlgoliaSearchCore.js#L232-L240\n    var key = \"/1/indexes/*/queries_body_\".concat(JSON.stringify({\n      requests: results.reduce(function (acc, result) {\n        return acc.concat(result.rawResults.map(function (request) {\n          return {\n            indexName: request.index,\n            params: request.params\n          };\n        }));\n      }, [])\n    }));\n    client.cache = _objectSpread(_objectSpread({}, client.cache), {}, _defineProperty({}, key, JSON.stringify({\n      results: results.reduce(function (acc, result) {\n        return acc.concat(result.rawResults);\n      }, [])\n    })));\n  }\n  function hydrateSearchClientWithSingleIndexRequest(client, results) {\n    // Algoliasearch API Client >= v4\n    // Populate the cache with the data from the server\n    if (client.transporter) {\n      client.transporter.responsesCache.set({\n        method: 'search',\n        args: [results.rawResults.map(function (request) {\n          return {\n            indexName: request.index,\n            params: request.params\n          };\n        })]\n      }, {\n        results: results.rawResults\n      });\n      return;\n    }\n    // Algoliasearch API Client < v4\n    // Prior to client v4 we didn't have a proper API to hydrate the client\n    // cache from the outside. The following code populates the cache with\n    // a single-index result. You can find more information about the\n    // computation of the key inside the client (see link below).\n    // https://github.com/algolia/algoliasearch-client-javascript/blob/c27e89ff92b2a854ae6f40dc524bffe0f0cbc169/src/AlgoliaSearchCore.js#L232-L240\n    var key = \"/1/indexes/*/queries_body_\".concat(JSON.stringify({\n      requests: results.rawResults.map(function (request) {\n        return {\n          indexName: request.index,\n          params: request.params\n        };\n      })\n    }));\n    client.cache = _objectSpread(_objectSpread({}, client.cache), {}, _defineProperty({}, key, JSON.stringify({\n      results: results.rawResults\n    })));\n  }\n  function hydrateResultsState(results) {\n    if (!results) {\n      return null;\n    }\n    if (Array.isArray(results.results)) {\n      return results.results.reduce(function (acc, result) {\n        return _objectSpread(_objectSpread({}, acc), {}, _defineProperty({}, result._internalIndexId, new algoliasearchHelper.SearchResults(new algoliasearchHelper.SearchParameters(result.state), result.rawResults)));\n      }, {});\n    }\n    return new algoliasearchHelper.SearchResults(new algoliasearchHelper.SearchParameters(results.state), results.rawResults);\n  }\n\n  // Called whenever a widget has been rendered with new props.\n  function onWidgetsUpdate() {\n    var metadata = getMetadata(store.getState().widgets);\n    store.setState(_objectSpread(_objectSpread({}, store.getState()), {}, {\n      metadata: metadata,\n      searching: true\n    }));\n\n    // Since the `getSearchParameters` method of widgets also depends on props,\n    // the result search parameters might have changed.\n    search();\n  }\n  function transitionState(nextSearchState) {\n    var searchState = store.getState().widgets;\n    return widgetsManager.getWidgets().filter(function (widget) {\n      return Boolean(widget.transitionState);\n    }).reduce(function (res, widget) {\n      return widget.transitionState(searchState, res);\n    }, nextSearchState);\n  }\n  function onExternalStateUpdate(nextSearchState) {\n    var metadata = getMetadata(nextSearchState);\n    store.setState(_objectSpread(_objectSpread({}, store.getState()), {}, {\n      widgets: nextSearchState,\n      metadata: metadata,\n      searching: true\n    }));\n    search();\n  }\n  function onSearchForFacetValues(_ref5) {\n    var facetName = _ref5.facetName,\n      query = _ref5.query,\n      _ref5$maxFacetHits = _ref5.maxFacetHits,\n      maxFacetHits = _ref5$maxFacetHits === void 0 ? 10 : _ref5$maxFacetHits;\n    // The values 1, 100 are the min / max values that the engine accepts.\n    // see: https://www.algolia.com/doc/api-reference/api-parameters/maxFacetHits\n    var maxFacetHitsWithinRange = Math.max(1, Math.min(maxFacetHits, 100));\n    store.setState(_objectSpread(_objectSpread({}, store.getState()), {}, {\n      searchingForFacetValues: true\n    }));\n    helper.searchForFacetValues(facetName, query, maxFacetHitsWithinRange).then(function (content) {\n      var _objectSpread7;\n      store.setState(_objectSpread(_objectSpread({}, store.getState()), {}, {\n        error: null,\n        searchingForFacetValues: false,\n        resultsFacetValues: _objectSpread(_objectSpread({}, store.getState().resultsFacetValues), {}, (_objectSpread7 = {}, _defineProperty(_objectSpread7, facetName, content.facetHits), _defineProperty(_objectSpread7, \"query\", query), _objectSpread7))\n      }));\n    }, function (error) {\n      store.setState(_objectSpread(_objectSpread({}, store.getState()), {}, {\n        searchingForFacetValues: false,\n        error: error\n      }));\n    }).catch(function (error) {\n      // Since setState is synchronous, any error that occurs in the render of a\n      // component will be swallowed by this promise.\n      // This is a trick to make the error show up correctly in the console.\n      // See http://stackoverflow.com/a/30741722/969302\n      setTimeout(function () {\n        throw error;\n      });\n    });\n  }\n  function updateIndex(newIndex) {\n    initialSearchParameters = initialSearchParameters.setIndex(newIndex);\n    // No need to trigger a new search here as the widgets will also update and trigger it if needed.\n  }\n\n  function getWidgetsIds() {\n    return store.getState().metadata.reduce(function (res, meta) {\n      return typeof meta.id !== 'undefined' ? res.concat(meta.id) : res;\n    }, []);\n  }\n  return {\n    store: store,\n    widgetsManager: widgetsManager,\n    getWidgetsIds: getWidgetsIds,\n    getSearchParameters: getSearchParameters,\n    onSearchForFacetValues: onSearchForFacetValues,\n    onExternalStateUpdate: onExternalStateUpdate,\n    transitionState: transitionState,\n    updateClient: updateClient,\n    updateIndex: updateIndex,\n    clearCache: clearCache,\n    skipSearch: skipSearch\n  };\n}\nfunction hydrateMetadata(resultsState) {\n  if (!resultsState) {\n    return [];\n  }\n\n  // add a value noop, which gets replaced once the widgets are mounted\n  return resultsState.metadata.map(function (datum) {\n    return _objectSpread(_objectSpread({\n      value: function value() {\n        return {};\n      }\n    }, datum), {}, {\n      items: datum.items && datum.items.map(function (item) {\n        return _objectSpread(_objectSpread({\n          value: function value() {\n            return {};\n          }\n        }, item), {}, {\n          items: item.items && item.items.map(function (nestedItem) {\n            return _objectSpread({\n              value: function value() {\n                return {};\n              }\n            }, nestedItem);\n          })\n        });\n      })\n    });\n  });\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}