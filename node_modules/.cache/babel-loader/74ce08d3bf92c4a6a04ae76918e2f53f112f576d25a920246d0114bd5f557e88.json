{"ast":null,"code":"var buildSearchMethod = require('./buildSearchMethod.js');\nvar deprecate = require('./deprecate.js');\nvar deprecatedMessage = require('./deprecatedMessage.js');\nmodule.exports = IndexCore;\n\n/*\n* Index class constructor.\n* You should not use this method directly but use initIndex() function\n*/\nfunction IndexCore(algoliasearch, indexName) {\n  this.indexName = indexName;\n  this.as = algoliasearch;\n  this.typeAheadArgs = null;\n  this.typeAheadValueOption = null;\n\n  // make sure every index instance has it's own cache\n  this.cache = {};\n}\n\n/*\n* Clear all queries in cache\n*/\nIndexCore.prototype.clearCache = function () {\n  this.cache = {};\n};\n\n/*\n* Search inside the index using XMLHttpRequest request (Using a POST query to\n* minimize number of OPTIONS queries: Cross-Origin Resource Sharing).\n*\n* @param {string} [query] the full text query\n* @param {object} [args] (optional) if set, contains an object with query parameters:\n* - page: (integer) Pagination parameter used to select the page to retrieve.\n*                   Page is zero-based and defaults to 0. Thus,\n*                   to retrieve the 10th page you need to set page=9\n* - hitsPerPage: (integer) Pagination parameter used to select the number of hits per page. Defaults to 20.\n* - attributesToRetrieve: a string that contains the list of object attributes\n* you want to retrieve (let you minimize the answer size).\n*   Attributes are separated with a comma (for example \"name,address\").\n*   You can also use an array (for example [\"name\",\"address\"]).\n*   By default, all attributes are retrieved. You can also use '*' to retrieve all\n*   values when an attributesToRetrieve setting is specified for your index.\n* - attributesToHighlight: a string that contains the list of attributes you\n*   want to highlight according to the query.\n*   Attributes are separated by a comma. You can also use an array (for example [\"name\",\"address\"]).\n*   If an attribute has no match for the query, the raw value is returned.\n*   By default all indexed text attributes are highlighted.\n*   You can use `*` if you want to highlight all textual attributes.\n*   Numerical attributes are not highlighted.\n*   A matchLevel is returned for each highlighted attribute and can contain:\n*      - full: if all the query terms were found in the attribute,\n*      - partial: if only some of the query terms were found,\n*      - none: if none of the query terms were found.\n* - attributesToSnippet: a string that contains the list of attributes to snippet alongside\n* the number of words to return (syntax is `attributeName:nbWords`).\n*    Attributes are separated by a comma (Example: attributesToSnippet=name:10,content:10).\n*    You can also use an array (Example: attributesToSnippet: ['name:10','content:10']).\n*    By default no snippet is computed.\n* - minWordSizefor1Typo: the minimum number of characters in a query word to accept one typo in this word.\n* Defaults to 3.\n* - minWordSizefor2Typos: the minimum number of characters in a query word\n* to accept two typos in this word. Defaults to 7.\n* - getRankingInfo: if set to 1, the result hits will contain ranking\n* information in _rankingInfo attribute.\n* - aroundLatLng: search for entries around a given\n* latitude/longitude (specified as two floats separated by a comma).\n*   For example aroundLatLng=47.316669,5.016670).\n*   You can specify the maximum distance in meters with the aroundRadius parameter (in meters)\n*   and the precision for ranking with aroundPrecision\n*   (for example if you set aroundPrecision=100, two objects that are distant of\n*   less than 100m will be considered as identical for \"geo\" ranking parameter).\n*   At indexing, you should specify geoloc of an object with the _geoloc attribute\n*   (in the form {\"_geoloc\":{\"lat\":48.853409, \"lng\":2.348800}})\n* - insideBoundingBox: search entries inside a given area defined by the two extreme points\n* of a rectangle (defined by 4 floats: p1Lat,p1Lng,p2Lat,p2Lng).\n*   For example insideBoundingBox=47.3165,4.9665,47.3424,5.0201).\n*   At indexing, you should specify geoloc of an object with the _geoloc attribute\n*   (in the form {\"_geoloc\":{\"lat\":48.853409, \"lng\":2.348800}})\n* - numericFilters: a string that contains the list of numeric filters you want to\n* apply separated by a comma.\n*   The syntax of one filter is `attributeName` followed by `operand` followed by `value`.\n*   Supported operands are `<`, `<=`, `=`, `>` and `>=`.\n*   You can have multiple conditions on one attribute like for example numericFilters=price>100,price<1000.\n*   You can also use an array (for example numericFilters: [\"price>100\",\"price<1000\"]).\n* - tagFilters: filter the query by a set of tags. You can AND tags by separating them by commas.\n*   To OR tags, you must add parentheses. For example, tags=tag1,(tag2,tag3) means tag1 AND (tag2 OR tag3).\n*   You can also use an array, for example tagFilters: [\"tag1\",[\"tag2\",\"tag3\"]]\n*   means tag1 AND (tag2 OR tag3).\n*   At indexing, tags should be added in the _tags** attribute\n*   of objects (for example {\"_tags\":[\"tag1\",\"tag2\"]}).\n* - facetFilters: filter the query by a list of facets.\n*   Facets are separated by commas and each facet is encoded as `attributeName:value`.\n*   For example: `facetFilters=category:Book,author:John%20Doe`.\n*   You can also use an array (for example `[\"category:Book\",\"author:John%20Doe\"]`).\n* - facets: List of object attributes that you want to use for faceting.\n*   Comma separated list: `\"category,author\"` or array `['category','author']`\n*   Only attributes that have been added in **attributesForFaceting** index setting\n*   can be used in this parameter.\n*   You can also use `*` to perform faceting on all attributes specified in **attributesForFaceting**.\n* - queryType: select how the query words are interpreted, it can be one of the following value:\n*    - prefixAll: all query words are interpreted as prefixes,\n*    - prefixLast: only the last word is interpreted as a prefix (default behavior),\n*    - prefixNone: no query word is interpreted as a prefix. This option is not recommended.\n* - optionalWords: a string that contains the list of words that should\n* be considered as optional when found in the query.\n*   Comma separated and array are accepted.\n* - distinct: If set to 1, enable the distinct feature (disabled by default)\n* if the attributeForDistinct index setting is set.\n*   This feature is similar to the SQL \"distinct\" keyword: when enabled\n*   in a query with the distinct=1 parameter,\n*   all hits containing a duplicate value for the attributeForDistinct attribute are removed from results.\n*   For example, if the chosen attribute is show_name and several hits have\n*   the same value for show_name, then only the best\n*   one is kept and others are removed.\n* - restrictSearchableAttributes: List of attributes you want to use for\n* textual search (must be a subset of the attributesToIndex index setting)\n* either comma separated or as an array\n* @param {function} [callback] the result callback called with two arguments:\n*  error: null or Error('message'). If false, the content contains the error.\n*  content: the server answer that contains the list of results.\n*/\nIndexCore.prototype.search = buildSearchMethod('query');\n\n/*\n* -- BETA --\n* Search a record similar to the query inside the index using XMLHttpRequest request (Using a POST query to\n* minimize number of OPTIONS queries: Cross-Origin Resource Sharing).\n*\n* @param {string} [query] the similar query\n* @param {object} [args] (optional) if set, contains an object with query parameters.\n*   All search parameters are supported (see search function), restrictSearchableAttributes and facetFilters\n*   are the two most useful to restrict the similar results and get more relevant content\n*/\nIndexCore.prototype.similarSearch = deprecate(buildSearchMethod('similarQuery'), deprecatedMessage('index.similarSearch(query[, callback])', 'index.search({ similarQuery: query }[, callback])'));\n\n/*\n* Browse index content. The response content will have a `cursor` property that you can use\n* to browse subsequent pages for this query. Use `index.browseFrom(cursor)` when you want.\n*\n* @param {string} query - The full text query\n* @param {Object} [queryParameters] - Any search query parameter\n* @param {Function} [callback] - The result callback called with two arguments\n*   error: null or Error('message')\n*   content: the server answer with the browse result\n* @return {Promise|undefined} Returns a promise if no callback given\n* @example\n* index.browse('cool songs', {\n*   tagFilters: 'public,comments',\n*   hitsPerPage: 500\n* }, callback);\n* @see {@link https://www.algolia.com/doc/rest_api#Browse|Algolia REST API Documentation}\n*/\nIndexCore.prototype.browse = function (query, queryParameters, callback) {\n  var merge = require('./merge.js');\n  var indexObj = this;\n  var page;\n  var hitsPerPage;\n\n  // we check variadic calls that are not the one defined\n  // .browse()/.browse(fn)\n  // => page = 0\n  if (arguments.length === 0 || arguments.length === 1 && typeof arguments[0] === 'function') {\n    page = 0;\n    callback = arguments[0];\n    query = undefined;\n  } else if (typeof arguments[0] === 'number') {\n    // .browse(2)/.browse(2, 10)/.browse(2, fn)/.browse(2, 10, fn)\n    page = arguments[0];\n    if (typeof arguments[1] === 'number') {\n      hitsPerPage = arguments[1];\n    } else if (typeof arguments[1] === 'function') {\n      callback = arguments[1];\n      hitsPerPage = undefined;\n    }\n    query = undefined;\n    queryParameters = undefined;\n  } else if (typeof arguments[0] === 'object') {\n    // .browse(queryParameters)/.browse(queryParameters, cb)\n    if (typeof arguments[1] === 'function') {\n      callback = arguments[1];\n    }\n    queryParameters = arguments[0];\n    query = undefined;\n  } else if (typeof arguments[0] === 'string' && typeof arguments[1] === 'function') {\n    // .browse(query, cb)\n    callback = arguments[1];\n    queryParameters = undefined;\n  }\n\n  // otherwise it's a .browse(query)/.browse(query, queryParameters)/.browse(query, queryParameters, cb)\n\n  // get search query parameters combining various possible calls\n  // to .browse();\n  queryParameters = merge({}, queryParameters || {}, {\n    page: page,\n    hitsPerPage: hitsPerPage,\n    query: query\n  });\n  var params = this.as._getSearchParams(queryParameters, '');\n  return this.as._jsonRequest({\n    method: 'POST',\n    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/browse',\n    body: {\n      params: params\n    },\n    hostType: 'read',\n    callback: callback\n  });\n};\n\n/*\n* Continue browsing from a previous position (cursor), obtained via a call to `.browse()`.\n*\n* @param {string} query - The full text query\n* @param {Object} [queryParameters] - Any search query parameter\n* @param {Function} [callback] - The result callback called with two arguments\n*   error: null or Error('message')\n*   content: the server answer with the browse result\n* @return {Promise|undefined} Returns a promise if no callback given\n* @example\n* index.browseFrom('14lkfsakl32', callback);\n* @see {@link https://www.algolia.com/doc/rest_api#Browse|Algolia REST API Documentation}\n*/\nIndexCore.prototype.browseFrom = function (cursor, callback) {\n  return this.as._jsonRequest({\n    method: 'POST',\n    url: '/1/indexes/' + encodeURIComponent(this.indexName) + '/browse',\n    body: {\n      cursor: cursor\n    },\n    hostType: 'read',\n    callback: callback\n  });\n};\n\n/*\n* Search for facet values\n* https://www.algolia.com/doc/rest-api/search#search-for-facet-values\n*\n* @param {string} params.facetName Facet name, name of the attribute to search for values in.\n* Must be declared as a facet\n* @param {string} params.facetQuery Query for the facet search\n* @param {string} [params.*] Any search parameter of Algolia,\n* see https://www.algolia.com/doc/api-client/javascript/search#search-parameters\n* Pagination is not supported. The page and hitsPerPage parameters will be ignored.\n* @param callback (optional)\n*/\nIndexCore.prototype.searchForFacetValues = function (params, callback) {\n  var clone = require('./clone.js');\n  var omit = require('./omit.js');\n  var usage = 'Usage: index.searchForFacetValues({facetName, facetQuery, ...params}[, callback])';\n  if (params.facetName === undefined || params.facetQuery === undefined) {\n    throw new Error(usage);\n  }\n  var facetName = params.facetName;\n  var filteredParams = omit(clone(params), function (keyName) {\n    return keyName === 'facetName';\n  });\n  var searchParameters = this.as._getSearchParams(filteredParams, '');\n  return this.as._jsonRequest({\n    method: 'POST',\n    url: '/1/indexes/' + encodeURIComponent(this.indexName) + '/facets/' + encodeURIComponent(facetName) + '/query',\n    hostType: 'read',\n    body: {\n      params: searchParameters\n    },\n    callback: callback\n  });\n};\nIndexCore.prototype.searchFacet = deprecate(function (params, callback) {\n  return this.searchForFacetValues(params, callback);\n}, deprecatedMessage('index.searchFacet(params[, callback])', 'index.searchForFacetValues(params[, callback])'));\nIndexCore.prototype._search = function (params, url, callback, additionalUA) {\n  return this.as._jsonRequest({\n    cache: this.cache,\n    method: 'POST',\n    url: url || '/1/indexes/' + encodeURIComponent(this.indexName) + '/query',\n    body: {\n      params: params\n    },\n    hostType: 'read',\n    fallback: {\n      method: 'GET',\n      url: '/1/indexes/' + encodeURIComponent(this.indexName),\n      body: {\n        params: params\n      }\n    },\n    callback: callback,\n    additionalUA: additionalUA\n  });\n};\n\n/*\n* Get an object from this index\n*\n* @param objectID the unique identifier of the object to retrieve\n* @param attrs (optional) if set, contains the array of attribute names to retrieve\n* @param callback (optional) the result callback called with two arguments\n*  error: null or Error('message')\n*  content: the object to retrieve or the error message if a failure occurred\n*/\nIndexCore.prototype.getObject = function (objectID, attrs, callback) {\n  var indexObj = this;\n  if (arguments.length === 1 || typeof attrs === 'function') {\n    callback = attrs;\n    attrs = undefined;\n  }\n  var params = '';\n  if (attrs !== undefined) {\n    params = '?attributes=';\n    for (var i = 0; i < attrs.length; ++i) {\n      if (i !== 0) {\n        params += ',';\n      }\n      params += attrs[i];\n    }\n  }\n  return this.as._jsonRequest({\n    method: 'GET',\n    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/' + encodeURIComponent(objectID) + params,\n    hostType: 'read',\n    callback: callback\n  });\n};\n\n/*\n* Get several objects from this index\n*\n* @param objectIDs the array of unique identifier of objects to retrieve\n*/\nIndexCore.prototype.getObjects = function (objectIDs, attributesToRetrieve, callback) {\n  var isArray = require('isarray');\n  var map = require('./map.js');\n  var usage = 'Usage: index.getObjects(arrayOfObjectIDs[, callback])';\n  if (!isArray(objectIDs)) {\n    throw new Error(usage);\n  }\n  var indexObj = this;\n  if (arguments.length === 1 || typeof attributesToRetrieve === 'function') {\n    callback = attributesToRetrieve;\n    attributesToRetrieve = undefined;\n  }\n  var body = {\n    requests: map(objectIDs, function prepareRequest(objectID) {\n      var request = {\n        indexName: indexObj.indexName,\n        objectID: objectID\n      };\n      if (attributesToRetrieve) {\n        request.attributesToRetrieve = attributesToRetrieve.join(',');\n      }\n      return request;\n    })\n  };\n  return this.as._jsonRequest({\n    method: 'POST',\n    url: '/1/indexes/*/objects',\n    hostType: 'read',\n    body: body,\n    callback: callback\n  });\n};\nIndexCore.prototype.as = null;\nIndexCore.prototype.indexName = null;\nIndexCore.prototype.typeAheadArgs = null;\nIndexCore.prototype.typeAheadValueOption = null;","map":{"version":3,"names":["buildSearchMethod","require","deprecate","deprecatedMessage","module","exports","IndexCore","algoliasearch","indexName","as","typeAheadArgs","typeAheadValueOption","cache","prototype","clearCache","search","similarSearch","browse","query","queryParameters","callback","merge","indexObj","page","hitsPerPage","arguments","length","undefined","params","_getSearchParams","_jsonRequest","method","url","encodeURIComponent","body","hostType","browseFrom","cursor","searchForFacetValues","clone","omit","usage","facetName","facetQuery","Error","filteredParams","keyName","searchParameters","searchFacet","_search","additionalUA","fallback","getObject","objectID","attrs","i","getObjects","objectIDs","attributesToRetrieve","isArray","map","requests","prepareRequest","request","join"],"sources":["/Users/amandawinkler/Desktop/algolia-instantsearch-react-geo/node_modules/algoliasearch/src/IndexCore.js"],"sourcesContent":["var buildSearchMethod = require('./buildSearchMethod.js');\nvar deprecate = require('./deprecate.js');\nvar deprecatedMessage = require('./deprecatedMessage.js');\n\nmodule.exports = IndexCore;\n\n/*\n* Index class constructor.\n* You should not use this method directly but use initIndex() function\n*/\nfunction IndexCore(algoliasearch, indexName) {\n  this.indexName = indexName;\n  this.as = algoliasearch;\n  this.typeAheadArgs = null;\n  this.typeAheadValueOption = null;\n\n  // make sure every index instance has it's own cache\n  this.cache = {};\n}\n\n/*\n* Clear all queries in cache\n*/\nIndexCore.prototype.clearCache = function() {\n  this.cache = {};\n};\n\n/*\n* Search inside the index using XMLHttpRequest request (Using a POST query to\n* minimize number of OPTIONS queries: Cross-Origin Resource Sharing).\n*\n* @param {string} [query] the full text query\n* @param {object} [args] (optional) if set, contains an object with query parameters:\n* - page: (integer) Pagination parameter used to select the page to retrieve.\n*                   Page is zero-based and defaults to 0. Thus,\n*                   to retrieve the 10th page you need to set page=9\n* - hitsPerPage: (integer) Pagination parameter used to select the number of hits per page. Defaults to 20.\n* - attributesToRetrieve: a string that contains the list of object attributes\n* you want to retrieve (let you minimize the answer size).\n*   Attributes are separated with a comma (for example \"name,address\").\n*   You can also use an array (for example [\"name\",\"address\"]).\n*   By default, all attributes are retrieved. You can also use '*' to retrieve all\n*   values when an attributesToRetrieve setting is specified for your index.\n* - attributesToHighlight: a string that contains the list of attributes you\n*   want to highlight according to the query.\n*   Attributes are separated by a comma. You can also use an array (for example [\"name\",\"address\"]).\n*   If an attribute has no match for the query, the raw value is returned.\n*   By default all indexed text attributes are highlighted.\n*   You can use `*` if you want to highlight all textual attributes.\n*   Numerical attributes are not highlighted.\n*   A matchLevel is returned for each highlighted attribute and can contain:\n*      - full: if all the query terms were found in the attribute,\n*      - partial: if only some of the query terms were found,\n*      - none: if none of the query terms were found.\n* - attributesToSnippet: a string that contains the list of attributes to snippet alongside\n* the number of words to return (syntax is `attributeName:nbWords`).\n*    Attributes are separated by a comma (Example: attributesToSnippet=name:10,content:10).\n*    You can also use an array (Example: attributesToSnippet: ['name:10','content:10']).\n*    By default no snippet is computed.\n* - minWordSizefor1Typo: the minimum number of characters in a query word to accept one typo in this word.\n* Defaults to 3.\n* - minWordSizefor2Typos: the minimum number of characters in a query word\n* to accept two typos in this word. Defaults to 7.\n* - getRankingInfo: if set to 1, the result hits will contain ranking\n* information in _rankingInfo attribute.\n* - aroundLatLng: search for entries around a given\n* latitude/longitude (specified as two floats separated by a comma).\n*   For example aroundLatLng=47.316669,5.016670).\n*   You can specify the maximum distance in meters with the aroundRadius parameter (in meters)\n*   and the precision for ranking with aroundPrecision\n*   (for example if you set aroundPrecision=100, two objects that are distant of\n*   less than 100m will be considered as identical for \"geo\" ranking parameter).\n*   At indexing, you should specify geoloc of an object with the _geoloc attribute\n*   (in the form {\"_geoloc\":{\"lat\":48.853409, \"lng\":2.348800}})\n* - insideBoundingBox: search entries inside a given area defined by the two extreme points\n* of a rectangle (defined by 4 floats: p1Lat,p1Lng,p2Lat,p2Lng).\n*   For example insideBoundingBox=47.3165,4.9665,47.3424,5.0201).\n*   At indexing, you should specify geoloc of an object with the _geoloc attribute\n*   (in the form {\"_geoloc\":{\"lat\":48.853409, \"lng\":2.348800}})\n* - numericFilters: a string that contains the list of numeric filters you want to\n* apply separated by a comma.\n*   The syntax of one filter is `attributeName` followed by `operand` followed by `value`.\n*   Supported operands are `<`, `<=`, `=`, `>` and `>=`.\n*   You can have multiple conditions on one attribute like for example numericFilters=price>100,price<1000.\n*   You can also use an array (for example numericFilters: [\"price>100\",\"price<1000\"]).\n* - tagFilters: filter the query by a set of tags. You can AND tags by separating them by commas.\n*   To OR tags, you must add parentheses. For example, tags=tag1,(tag2,tag3) means tag1 AND (tag2 OR tag3).\n*   You can also use an array, for example tagFilters: [\"tag1\",[\"tag2\",\"tag3\"]]\n*   means tag1 AND (tag2 OR tag3).\n*   At indexing, tags should be added in the _tags** attribute\n*   of objects (for example {\"_tags\":[\"tag1\",\"tag2\"]}).\n* - facetFilters: filter the query by a list of facets.\n*   Facets are separated by commas and each facet is encoded as `attributeName:value`.\n*   For example: `facetFilters=category:Book,author:John%20Doe`.\n*   You can also use an array (for example `[\"category:Book\",\"author:John%20Doe\"]`).\n* - facets: List of object attributes that you want to use for faceting.\n*   Comma separated list: `\"category,author\"` or array `['category','author']`\n*   Only attributes that have been added in **attributesForFaceting** index setting\n*   can be used in this parameter.\n*   You can also use `*` to perform faceting on all attributes specified in **attributesForFaceting**.\n* - queryType: select how the query words are interpreted, it can be one of the following value:\n*    - prefixAll: all query words are interpreted as prefixes,\n*    - prefixLast: only the last word is interpreted as a prefix (default behavior),\n*    - prefixNone: no query word is interpreted as a prefix. This option is not recommended.\n* - optionalWords: a string that contains the list of words that should\n* be considered as optional when found in the query.\n*   Comma separated and array are accepted.\n* - distinct: If set to 1, enable the distinct feature (disabled by default)\n* if the attributeForDistinct index setting is set.\n*   This feature is similar to the SQL \"distinct\" keyword: when enabled\n*   in a query with the distinct=1 parameter,\n*   all hits containing a duplicate value for the attributeForDistinct attribute are removed from results.\n*   For example, if the chosen attribute is show_name and several hits have\n*   the same value for show_name, then only the best\n*   one is kept and others are removed.\n* - restrictSearchableAttributes: List of attributes you want to use for\n* textual search (must be a subset of the attributesToIndex index setting)\n* either comma separated or as an array\n* @param {function} [callback] the result callback called with two arguments:\n*  error: null or Error('message'). If false, the content contains the error.\n*  content: the server answer that contains the list of results.\n*/\nIndexCore.prototype.search = buildSearchMethod('query');\n\n/*\n* -- BETA --\n* Search a record similar to the query inside the index using XMLHttpRequest request (Using a POST query to\n* minimize number of OPTIONS queries: Cross-Origin Resource Sharing).\n*\n* @param {string} [query] the similar query\n* @param {object} [args] (optional) if set, contains an object with query parameters.\n*   All search parameters are supported (see search function), restrictSearchableAttributes and facetFilters\n*   are the two most useful to restrict the similar results and get more relevant content\n*/\nIndexCore.prototype.similarSearch = deprecate(\n  buildSearchMethod('similarQuery'),\n  deprecatedMessage(\n    'index.similarSearch(query[, callback])',\n    'index.search({ similarQuery: query }[, callback])'\n  )\n);\n\n/*\n* Browse index content. The response content will have a `cursor` property that you can use\n* to browse subsequent pages for this query. Use `index.browseFrom(cursor)` when you want.\n*\n* @param {string} query - The full text query\n* @param {Object} [queryParameters] - Any search query parameter\n* @param {Function} [callback] - The result callback called with two arguments\n*   error: null or Error('message')\n*   content: the server answer with the browse result\n* @return {Promise|undefined} Returns a promise if no callback given\n* @example\n* index.browse('cool songs', {\n*   tagFilters: 'public,comments',\n*   hitsPerPage: 500\n* }, callback);\n* @see {@link https://www.algolia.com/doc/rest_api#Browse|Algolia REST API Documentation}\n*/\nIndexCore.prototype.browse = function(query, queryParameters, callback) {\n  var merge = require('./merge.js');\n\n  var indexObj = this;\n\n  var page;\n  var hitsPerPage;\n\n  // we check variadic calls that are not the one defined\n  // .browse()/.browse(fn)\n  // => page = 0\n  if (arguments.length === 0 || arguments.length === 1 && typeof arguments[0] === 'function') {\n    page = 0;\n    callback = arguments[0];\n    query = undefined;\n  } else if (typeof arguments[0] === 'number') {\n    // .browse(2)/.browse(2, 10)/.browse(2, fn)/.browse(2, 10, fn)\n    page = arguments[0];\n    if (typeof arguments[1] === 'number') {\n      hitsPerPage = arguments[1];\n    } else if (typeof arguments[1] === 'function') {\n      callback = arguments[1];\n      hitsPerPage = undefined;\n    }\n    query = undefined;\n    queryParameters = undefined;\n  } else if (typeof arguments[0] === 'object') {\n    // .browse(queryParameters)/.browse(queryParameters, cb)\n    if (typeof arguments[1] === 'function') {\n      callback = arguments[1];\n    }\n    queryParameters = arguments[0];\n    query = undefined;\n  } else if (typeof arguments[0] === 'string' && typeof arguments[1] === 'function') {\n    // .browse(query, cb)\n    callback = arguments[1];\n    queryParameters = undefined;\n  }\n\n  // otherwise it's a .browse(query)/.browse(query, queryParameters)/.browse(query, queryParameters, cb)\n\n  // get search query parameters combining various possible calls\n  // to .browse();\n  queryParameters = merge({}, queryParameters || {}, {\n    page: page,\n    hitsPerPage: hitsPerPage,\n    query: query\n  });\n\n  var params = this.as._getSearchParams(queryParameters, '');\n\n  return this.as._jsonRequest({\n    method: 'POST',\n    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/browse',\n    body: {params: params},\n    hostType: 'read',\n    callback: callback\n  });\n};\n\n/*\n* Continue browsing from a previous position (cursor), obtained via a call to `.browse()`.\n*\n* @param {string} query - The full text query\n* @param {Object} [queryParameters] - Any search query parameter\n* @param {Function} [callback] - The result callback called with two arguments\n*   error: null or Error('message')\n*   content: the server answer with the browse result\n* @return {Promise|undefined} Returns a promise if no callback given\n* @example\n* index.browseFrom('14lkfsakl32', callback);\n* @see {@link https://www.algolia.com/doc/rest_api#Browse|Algolia REST API Documentation}\n*/\nIndexCore.prototype.browseFrom = function(cursor, callback) {\n  return this.as._jsonRequest({\n    method: 'POST',\n    url: '/1/indexes/' + encodeURIComponent(this.indexName) + '/browse',\n    body: {cursor: cursor},\n    hostType: 'read',\n    callback: callback\n  });\n};\n\n/*\n* Search for facet values\n* https://www.algolia.com/doc/rest-api/search#search-for-facet-values\n*\n* @param {string} params.facetName Facet name, name of the attribute to search for values in.\n* Must be declared as a facet\n* @param {string} params.facetQuery Query for the facet search\n* @param {string} [params.*] Any search parameter of Algolia,\n* see https://www.algolia.com/doc/api-client/javascript/search#search-parameters\n* Pagination is not supported. The page and hitsPerPage parameters will be ignored.\n* @param callback (optional)\n*/\nIndexCore.prototype.searchForFacetValues = function(params, callback) {\n  var clone = require('./clone.js');\n  var omit = require('./omit.js');\n  var usage = 'Usage: index.searchForFacetValues({facetName, facetQuery, ...params}[, callback])';\n\n  if (params.facetName === undefined || params.facetQuery === undefined) {\n    throw new Error(usage);\n  }\n\n  var facetName = params.facetName;\n  var filteredParams = omit(clone(params), function(keyName) {\n    return keyName === 'facetName';\n  });\n  var searchParameters = this.as._getSearchParams(filteredParams, '');\n\n  return this.as._jsonRequest({\n    method: 'POST',\n    url: '/1/indexes/' +\n      encodeURIComponent(this.indexName) + '/facets/' + encodeURIComponent(facetName) + '/query',\n    hostType: 'read',\n    body: {params: searchParameters},\n    callback: callback\n  });\n};\n\nIndexCore.prototype.searchFacet = deprecate(function(params, callback) {\n  return this.searchForFacetValues(params, callback);\n}, deprecatedMessage(\n  'index.searchFacet(params[, callback])',\n  'index.searchForFacetValues(params[, callback])'\n));\n\nIndexCore.prototype._search = function(params, url, callback, additionalUA) {\n  return this.as._jsonRequest({\n    cache: this.cache,\n    method: 'POST',\n    url: url || '/1/indexes/' + encodeURIComponent(this.indexName) + '/query',\n    body: {params: params},\n    hostType: 'read',\n    fallback: {\n      method: 'GET',\n      url: '/1/indexes/' + encodeURIComponent(this.indexName),\n      body: {params: params}\n    },\n    callback: callback,\n    additionalUA: additionalUA\n  });\n};\n\n/*\n* Get an object from this index\n*\n* @param objectID the unique identifier of the object to retrieve\n* @param attrs (optional) if set, contains the array of attribute names to retrieve\n* @param callback (optional) the result callback called with two arguments\n*  error: null or Error('message')\n*  content: the object to retrieve or the error message if a failure occurred\n*/\nIndexCore.prototype.getObject = function(objectID, attrs, callback) {\n  var indexObj = this;\n\n  if (arguments.length === 1 || typeof attrs === 'function') {\n    callback = attrs;\n    attrs = undefined;\n  }\n\n  var params = '';\n  if (attrs !== undefined) {\n    params = '?attributes=';\n    for (var i = 0; i < attrs.length; ++i) {\n      if (i !== 0) {\n        params += ',';\n      }\n      params += attrs[i];\n    }\n  }\n\n  return this.as._jsonRequest({\n    method: 'GET',\n    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/' + encodeURIComponent(objectID) + params,\n    hostType: 'read',\n    callback: callback\n  });\n};\n\n/*\n* Get several objects from this index\n*\n* @param objectIDs the array of unique identifier of objects to retrieve\n*/\nIndexCore.prototype.getObjects = function(objectIDs, attributesToRetrieve, callback) {\n  var isArray = require('isarray');\n  var map = require('./map.js');\n\n  var usage = 'Usage: index.getObjects(arrayOfObjectIDs[, callback])';\n\n  if (!isArray(objectIDs)) {\n    throw new Error(usage);\n  }\n\n  var indexObj = this;\n\n  if (arguments.length === 1 || typeof attributesToRetrieve === 'function') {\n    callback = attributesToRetrieve;\n    attributesToRetrieve = undefined;\n  }\n\n  var body = {\n    requests: map(objectIDs, function prepareRequest(objectID) {\n      var request = {\n        indexName: indexObj.indexName,\n        objectID: objectID\n      };\n\n      if (attributesToRetrieve) {\n        request.attributesToRetrieve = attributesToRetrieve.join(',');\n      }\n\n      return request;\n    })\n  };\n\n  return this.as._jsonRequest({\n    method: 'POST',\n    url: '/1/indexes/*/objects',\n    hostType: 'read',\n    body: body,\n    callback: callback\n  });\n};\n\nIndexCore.prototype.as = null;\nIndexCore.prototype.indexName = null;\nIndexCore.prototype.typeAheadArgs = null;\nIndexCore.prototype.typeAheadValueOption = null;\n"],"mappings":"AAAA,IAAIA,iBAAiB,GAAGC,OAAO,CAAC,wBAAwB,CAAC;AACzD,IAAIC,SAAS,GAAGD,OAAO,CAAC,gBAAgB,CAAC;AACzC,IAAIE,iBAAiB,GAAGF,OAAO,CAAC,wBAAwB,CAAC;AAEzDG,MAAM,CAACC,OAAO,GAAGC,SAAS;;AAE1B;AACA;AACA;AACA;AACA,SAASA,SAASA,CAACC,aAAa,EAAEC,SAAS,EAAE;EAC3C,IAAI,CAACA,SAAS,GAAGA,SAAS;EAC1B,IAAI,CAACC,EAAE,GAAGF,aAAa;EACvB,IAAI,CAACG,aAAa,GAAG,IAAI;EACzB,IAAI,CAACC,oBAAoB,GAAG,IAAI;;EAEhC;EACA,IAAI,CAACC,KAAK,GAAG,CAAC,CAAC;AACjB;;AAEA;AACA;AACA;AACAN,SAAS,CAACO,SAAS,CAACC,UAAU,GAAG,YAAW;EAC1C,IAAI,CAACF,KAAK,GAAG,CAAC,CAAC;AACjB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAN,SAAS,CAACO,SAAS,CAACE,MAAM,GAAGf,iBAAiB,CAAC,OAAO,CAAC;;AAEvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAM,SAAS,CAACO,SAAS,CAACG,aAAa,GAAGd,SAAS,CAC3CF,iBAAiB,CAAC,cAAc,CAAC,EACjCG,iBAAi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"},"metadata":{},"sourceType":"script","externalDependencies":[]}