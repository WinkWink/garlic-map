{"ast":null,"code":"'use strict';\n\nfunction clone(value) {\n  if (typeof value === 'object' && value !== null) {\n    return _merge(Array.isArray(value) ? [] : {}, value);\n  }\n  return value;\n}\nfunction isObjectOrArrayOrFunction(value) {\n  return typeof value === 'function' || Array.isArray(value) || Object.prototype.toString.call(value) === '[object Object]';\n}\nfunction _merge(target, source) {\n  if (target === source) {\n    return target;\n  }\n  for (var key in source) {\n    if (!Object.prototype.hasOwnProperty.call(source, key) || key === '__proto__' || key === 'constructor') {\n      continue;\n    }\n    var sourceVal = source[key];\n    var targetVal = target[key];\n    if (typeof targetVal !== 'undefined' && typeof sourceVal === 'undefined') {\n      continue;\n    }\n    if (isObjectOrArrayOrFunction(targetVal) && isObjectOrArrayOrFunction(sourceVal)) {\n      target[key] = _merge(targetVal, sourceVal);\n    } else {\n      target[key] = clone(sourceVal);\n    }\n  }\n  return target;\n}\n\n/**\n * This method is like Object.assign, but recursively merges own and inherited\n * enumerable keyed properties of source objects into the destination object.\n *\n * NOTE: this behaves like lodash/merge, but:\n * - does mutate functions if they are a source\n * - treats non-plain objects as plain\n * - does not work for circular objects\n * - treats sparse arrays as sparse\n * - does not convert Array-like objects (Arguments, NodeLists, etc.) to arrays\n *\n * @param {Object} object The destination object.\n * @param {...Object} [sources] The source objects.\n * @returns {Object} Returns `object`.\n */\n\nfunction merge(target) {\n  if (!isObjectOrArrayOrFunction(target)) {\n    target = {};\n  }\n  for (var i = 1, l = arguments.length; i < l; i++) {\n    var source = arguments[i];\n    if (isObjectOrArrayOrFunction(source)) {\n      _merge(target, source);\n    }\n  }\n  return target;\n}\nmodule.exports = merge;","map":{"version":3,"names":["clone","value","_merge","Array","isArray","isObjectOrArrayOrFunction","Object","prototype","toString","call","target","source","key","hasOwnProperty","sourceVal","targetVal","merge","i","l","arguments","length","module","exports"],"sources":["/Users/amandawinkler/Desktop/algolia-instantsearch-react-geo/node_modules/algoliasearch-helper/src/functions/merge.js"],"sourcesContent":["'use strict';\n\nfunction clone(value) {\n  if (typeof value === 'object' && value !== null) {\n    return _merge(Array.isArray(value) ? [] : {}, value);\n  }\n  return value;\n}\n\nfunction isObjectOrArrayOrFunction(value) {\n  return (\n    typeof value === 'function' ||\n    Array.isArray(value) ||\n    Object.prototype.toString.call(value) === '[object Object]'\n  );\n}\n\nfunction _merge(target, source) {\n  if (target === source) {\n    return target;\n  }\n\n  for (var key in source) {\n    if (\n      !Object.prototype.hasOwnProperty.call(source, key) ||\n      key === '__proto__' ||\n      key === 'constructor'\n    ) {\n      continue;\n    }\n\n    var sourceVal = source[key];\n    var targetVal = target[key];\n\n    if (typeof targetVal !== 'undefined' && typeof sourceVal === 'undefined') {\n      continue;\n    }\n\n    if (\n      isObjectOrArrayOrFunction(targetVal) &&\n      isObjectOrArrayOrFunction(sourceVal)\n    ) {\n      target[key] = _merge(targetVal, sourceVal);\n    } else {\n      target[key] = clone(sourceVal);\n    }\n  }\n  return target;\n}\n\n/**\n * This method is like Object.assign, but recursively merges own and inherited\n * enumerable keyed properties of source objects into the destination object.\n *\n * NOTE: this behaves like lodash/merge, but:\n * - does mutate functions if they are a source\n * - treats non-plain objects as plain\n * - does not work for circular objects\n * - treats sparse arrays as sparse\n * - does not convert Array-like objects (Arguments, NodeLists, etc.) to arrays\n *\n * @param {Object} object The destination object.\n * @param {...Object} [sources] The source objects.\n * @returns {Object} Returns `object`.\n */\n\nfunction merge(target) {\n  if (!isObjectOrArrayOrFunction(target)) {\n    target = {};\n  }\n\n  for (var i = 1, l = arguments.length; i < l; i++) {\n    var source = arguments[i];\n\n    if (isObjectOrArrayOrFunction(source)) {\n      _merge(target, source);\n    }\n  }\n  return target;\n}\n\nmodule.exports = merge;\n"],"mappings":"AAAA,YAAY;;AAEZ,SAASA,KAAKA,CAACC,KAAK,EAAE;EACpB,IAAI,OAAOA,KAAK,KAAK,QAAQ,IAAIA,KAAK,KAAK,IAAI,EAAE;IAC/C,OAAOC,MAAM,CAACC,KAAK,CAACC,OAAO,CAACH,KAAK,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC,EAAEA,KAAK,CAAC;EACtD;EACA,OAAOA,KAAK;AACd;AAEA,SAASI,yBAAyBA,CAACJ,KAAK,EAAE;EACxC,OACE,OAAOA,KAAK,KAAK,UAAU,IAC3BE,KAAK,CAACC,OAAO,CAACH,KAAK,CAAC,IACpBK,MAAM,CAACC,SAAS,CAACC,QAAQ,CAACC,IAAI,CAACR,KAAK,CAAC,KAAK,iBAAiB;AAE/D;AAEA,SAASC,MAAMA,CAACQ,MAAM,EAAEC,MAAM,EAAE;EAC9B,IAAID,MAAM,KAAKC,MAAM,EAAE;IACrB,OAAOD,MAAM;EACf;EAEA,KAAK,IAAIE,GAAG,IAAID,MAAM,EAAE;IACtB,IACE,CAACL,MAAM,CAACC,SAAS,CAACM,cAAc,CAACJ,IAAI,CAACE,MAAM,EAAEC,GAAG,CAAC,IAClDA,GAAG,KAAK,WAAW,IACnBA,GAAG,KAAK,aAAa,EACrB;MACA;IACF;IAEA,IAAIE,SAAS,GAAGH,MAAM,CAACC,GAAG,CAAC;IAC3B,IAAIG,SAAS,GAAGL,MAAM,CAACE,GAAG,CAAC;IAE3B,IAAI,OAAOG,SAAS,KAAK,WAAW,IAAI,OAAOD,SAAS,KAAK,WAAW,EAAE;MACxE;IACF;IAEA,IACET,yBAAyB,CAACU,SAAS,CAAC,IACpCV,yBAAyB,CAACS,SAAS,CAAC,EACpC;MACAJ,MAAM,CAACE,GAAG,CAAC,GAAGV,MAAM,CAACa,SAAS,EAAED,SAAS,CAAC;IAC5C,CAAC,MAAM;MACLJ,MAAM,CAACE,GAAG,CAAC,GAAGZ,KAAK,CAACc,SAAS,CAAC;IAChC;EACF;EACA,OAAOJ,MAAM;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASM,KAAKA,CAACN,MAAM,EAAE;EACrB,IAAI,CAACL,yBAAyB,CAACK,MAAM,CAAC,EAAE;IACtCA,MAAM,GAAG,CAAC,CAAC;EACb;EAEA,KAAK,IAAIO,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGC,SAAS,CAACC,MAAM,EAAEH,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;IAChD,IAAIN,MAAM,GAAGQ,SAAS,CAACF,CAAC,CAAC;IAEzB,IAAIZ,yBAAyB,CAACM,MAAM,CAAC,EAAE;MACrCT,MAAM,CAACQ,MAAM,EAAEC,MAAM,CAAC;IACxB;EACF;EACA,OAAOD,MAAM;AACf;AAEAW,MAAM,CAACC,OAAO,GAAGN,KAAK"},"metadata":{},"sourceType":"script","externalDependencies":[]}